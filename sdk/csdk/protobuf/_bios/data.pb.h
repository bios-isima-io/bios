/*
 * Copyright (C) 2025 Isima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: _bios/data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED__5fbios_2fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED__5fbios_2fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT__5fbios_2fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct__5fbios_2fdata_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table__5fbios_2fdata_2eproto;
namespace com {
namespace isima {
namespace bios {
namespace models {
namespace proto {
class AttributeList;
struct AttributeListDefaultTypeInternal;
extern AttributeListDefaultTypeInternal _AttributeList_default_instance_;
class ColumnDefinition;
struct ColumnDefinitionDefaultTypeInternal;
extern ColumnDefinitionDefaultTypeInternal _ColumnDefinition_default_instance_;
class Dimensions;
struct DimensionsDefaultTypeInternal;
extern DimensionsDefaultTypeInternal _Dimensions_default_instance_;
class InsertBulkErrorResponse;
struct InsertBulkErrorResponseDefaultTypeInternal;
extern InsertBulkErrorResponseDefaultTypeInternal _InsertBulkErrorResponse_default_instance_;
class InsertBulkRequest;
struct InsertBulkRequestDefaultTypeInternal;
extern InsertBulkRequestDefaultTypeInternal _InsertBulkRequest_default_instance_;
class InsertBulkSuccessResponse;
struct InsertBulkSuccessResponseDefaultTypeInternal;
extern InsertBulkSuccessResponseDefaultTypeInternal _InsertBulkSuccessResponse_default_instance_;
class InsertRequest;
struct InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertSuccessOrError;
struct InsertSuccessOrErrorDefaultTypeInternal;
extern InsertSuccessOrErrorDefaultTypeInternal _InsertSuccessOrError_default_instance_;
class InsertSuccessResponse;
struct InsertSuccessResponseDefaultTypeInternal;
extern InsertSuccessResponseDefaultTypeInternal _InsertSuccessResponse_default_instance_;
class Metric;
struct MetricDefaultTypeInternal;
extern MetricDefaultTypeInternal _Metric_default_instance_;
class OrderBy;
struct OrderByDefaultTypeInternal;
extern OrderByDefaultTypeInternal _OrderBy_default_instance_;
class QueryResult;
struct QueryResultDefaultTypeInternal;
extern QueryResultDefaultTypeInternal _QueryResult_default_instance_;
class Record;
struct RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class SelectQuery;
struct SelectQueryDefaultTypeInternal;
extern SelectQueryDefaultTypeInternal _SelectQuery_default_instance_;
class SelectQueryResponse;
struct SelectQueryResponseDefaultTypeInternal;
extern SelectQueryResponseDefaultTypeInternal _SelectQueryResponse_default_instance_;
class SelectRequest;
struct SelectRequestDefaultTypeInternal;
extern SelectRequestDefaultTypeInternal _SelectRequest_default_instance_;
class SelectResponse;
struct SelectResponseDefaultTypeInternal;
extern SelectResponseDefaultTypeInternal _SelectResponse_default_instance_;
class SlidingWindow;
struct SlidingWindowDefaultTypeInternal;
extern SlidingWindowDefaultTypeInternal _SlidingWindow_default_instance_;
class TumblingWindow;
struct TumblingWindowDefaultTypeInternal;
extern TumblingWindowDefaultTypeInternal _TumblingWindow_default_instance_;
class Uuid;
struct UuidDefaultTypeInternal;
extern UuidDefaultTypeInternal _Uuid_default_instance_;
class Window;
struct WindowDefaultTypeInternal;
extern WindowDefaultTypeInternal _Window_default_instance_;
}  // namespace proto
}  // namespace models
}  // namespace bios
}  // namespace isima
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::isima::bios::models::proto::AttributeList* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::AttributeList>(Arena*);
template<> ::com::isima::bios::models::proto::ColumnDefinition* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::ColumnDefinition>(Arena*);
template<> ::com::isima::bios::models::proto::Dimensions* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::Dimensions>(Arena*);
template<> ::com::isima::bios::models::proto::InsertBulkErrorResponse* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::InsertBulkErrorResponse>(Arena*);
template<> ::com::isima::bios::models::proto::InsertBulkRequest* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::InsertBulkRequest>(Arena*);
template<> ::com::isima::bios::models::proto::InsertBulkSuccessResponse* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::InsertBulkSuccessResponse>(Arena*);
template<> ::com::isima::bios::models::proto::InsertRequest* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::InsertRequest>(Arena*);
template<> ::com::isima::bios::models::proto::InsertSuccessOrError* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::InsertSuccessOrError>(Arena*);
template<> ::com::isima::bios::models::proto::InsertSuccessResponse* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::InsertSuccessResponse>(Arena*);
template<> ::com::isima::bios::models::proto::Metric* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::Metric>(Arena*);
template<> ::com::isima::bios::models::proto::OrderBy* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::OrderBy>(Arena*);
template<> ::com::isima::bios::models::proto::QueryResult* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::QueryResult>(Arena*);
template<> ::com::isima::bios::models::proto::Record* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::Record>(Arena*);
template<> ::com::isima::bios::models::proto::SelectQuery* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::SelectQuery>(Arena*);
template<> ::com::isima::bios::models::proto::SelectQueryResponse* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::SelectQueryResponse>(Arena*);
template<> ::com::isima::bios::models::proto::SelectRequest* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::SelectRequest>(Arena*);
template<> ::com::isima::bios::models::proto::SelectResponse* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::SelectResponse>(Arena*);
template<> ::com::isima::bios::models::proto::SlidingWindow* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::SlidingWindow>(Arena*);
template<> ::com::isima::bios::models::proto::TumblingWindow* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::TumblingWindow>(Arena*);
template<> ::com::isima::bios::models::proto::Uuid* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::Uuid>(Arena*);
template<> ::com::isima::bios::models::proto::Window* Arena::CreateMaybeMessage<::com::isima::bios::models::proto::Window>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace isima {
namespace bios {
namespace models {
namespace proto {

enum MetricFunction : int {
  SUM = 0,
  COUNT = 1,
  MIN = 2,
  MAX = 3,
  LAST = 4,
  AVG = 5,
  VARIANCE = 6,
  STDDEV = 7,
  SKEWNESS = 8,
  KURTOSIS = 9,
  SUM2 = 10,
  SUM3 = 11,
  SUM4 = 12,
  MEDIAN = 31,
  P0_01 = 32,
  P0_1 = 33,
  P1 = 34,
  P10 = 35,
  P25 = 36,
  P50 = 37,
  P75 = 38,
  P90 = 39,
  P99 = 40,
  P99_9 = 41,
  P99_99 = 42,
  DISTINCTCOUNT = 61,
  DCLB1 = 62,
  DCUB1 = 63,
  DCLB2 = 64,
  DCUB2 = 65,
  DCLB3 = 66,
  DCUB3 = 67,
  NUMSAMPLES = 81,
  SAMPLINGFRACTION = 82,
  SAMPLECOUNTS = 83,
  SYNOPSIS = 101,
  MetricFunction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MetricFunction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MetricFunction_IsValid(int value);
constexpr MetricFunction MetricFunction_MIN = SUM;
constexpr MetricFunction MetricFunction_MAX = SYNOPSIS;
constexpr int MetricFunction_ARRAYSIZE = MetricFunction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetricFunction_descriptor();
template<typename T>
inline const std::string& MetricFunction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MetricFunction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MetricFunction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MetricFunction_descriptor(), enum_t_value);
}
inline bool MetricFunction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetricFunction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MetricFunction>(
    MetricFunction_descriptor(), name, value);
}
enum ContentRepresentation : int {
  NATIVE = 0,
  CSV = 1,
  UNTYPED = 2,
  ContentRepresentation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ContentRepresentation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ContentRepresentation_IsValid(int value);
constexpr ContentRepresentation ContentRepresentation_MIN = NATIVE;
constexpr ContentRepresentation ContentRepresentation_MAX = UNTYPED;
constexpr int ContentRepresentation_ARRAYSIZE = ContentRepresentation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentRepresentation_descriptor();
template<typename T>
inline const std::string& ContentRepresentation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentRepresentation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentRepresentation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentRepresentation_descriptor(), enum_t_value);
}
inline bool ContentRepresentation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentRepresentation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentRepresentation>(
    ContentRepresentation_descriptor(), name, value);
}
enum AttributeType : int {
  UNKNOWN = 0,
  INTEGER = 1,
  DECIMAL = 2,
  STRING = 3,
  BLOB = 4,
  BOOLEAN = 5,
  AttributeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AttributeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AttributeType_IsValid(int value);
constexpr AttributeType AttributeType_MIN = UNKNOWN;
constexpr AttributeType AttributeType_MAX = BOOLEAN;
constexpr int AttributeType_ARRAYSIZE = AttributeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttributeType_descriptor();
template<typename T>
inline const std::string& AttributeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttributeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttributeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttributeType_descriptor(), enum_t_value);
}
inline bool AttributeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttributeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttributeType>(
    AttributeType_descriptor(), name, value);
}
enum WindowType : int {
  GLOBAL_WINDOW = 0,
  SLIDING_WINDOW = 1,
  TUMBLING_WINDOW = 2,
  WindowType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WindowType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WindowType_IsValid(int value);
constexpr WindowType WindowType_MIN = GLOBAL_WINDOW;
constexpr WindowType WindowType_MAX = TUMBLING_WINDOW;
constexpr int WindowType_ARRAYSIZE = WindowType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WindowType_descriptor();
template<typename T>
inline const std::string& WindowType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WindowType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WindowType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WindowType_descriptor(), enum_t_value);
}
inline bool WindowType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WindowType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WindowType>(
    WindowType_descriptor(), name, value);
}
// ===================================================================

class Uuid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.Uuid) */ {
 public:
  inline Uuid() : Uuid(nullptr) {}
  ~Uuid() override;
  explicit PROTOBUF_CONSTEXPR Uuid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uuid(const Uuid& from);
  Uuid(Uuid&& from) noexcept
    : Uuid() {
    *this = ::std::move(from);
  }

  inline Uuid& operator=(const Uuid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uuid& operator=(Uuid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uuid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uuid* internal_default_instance() {
    return reinterpret_cast<const Uuid*>(
               &_Uuid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Uuid& a, Uuid& b) {
    a.Swap(&b);
  }
  inline void Swap(Uuid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uuid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uuid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uuid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uuid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Uuid& from) {
    Uuid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uuid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.Uuid";
  }
  protected:
  explicit Uuid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // uint64 hi = 1;
  void clear_hi();
  uint64_t hi() const;
  void set_hi(uint64_t value);
  private:
  uint64_t _internal_hi() const;
  void _internal_set_hi(uint64_t value);
  public:

  // uint64 lo = 2;
  void clear_lo();
  uint64_t lo() const;
  void set_lo(uint64_t value);
  private:
  uint64_t _internal_lo() const;
  void _internal_set_lo(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.Uuid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hi_;
    uint64_t lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class Dimensions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.Dimensions) */ {
 public:
  inline Dimensions() : Dimensions(nullptr) {}
  ~Dimensions() override;
  explicit PROTOBUF_CONSTEXPR Dimensions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dimensions(const Dimensions& from);
  Dimensions(Dimensions&& from) noexcept
    : Dimensions() {
    *this = ::std::move(from);
  }

  inline Dimensions& operator=(const Dimensions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dimensions& operator=(Dimensions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dimensions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dimensions* internal_default_instance() {
    return reinterpret_cast<const Dimensions*>(
               &_Dimensions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Dimensions& a, Dimensions& b) {
    a.Swap(&b);
  }
  inline void Swap(Dimensions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dimensions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dimensions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dimensions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dimensions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dimensions& from) {
    Dimensions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dimensions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.Dimensions";
  }
  protected:
  explicit Dimensions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionsFieldNumber = 1,
  };
  // repeated string dimensions = 1;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;
  public:
  void clear_dimensions();
  const std::string& dimensions(int index) const;
  std::string* mutable_dimensions(int index);
  void set_dimensions(int index, const std::string& value);
  void set_dimensions(int index, std::string&& value);
  void set_dimensions(int index, const char* value);
  void set_dimensions(int index, const char* value, size_t size);
  std::string* add_dimensions();
  void add_dimensions(const std::string& value);
  void add_dimensions(std::string&& value);
  void add_dimensions(const char* value);
  void add_dimensions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dimensions();
  private:
  const std::string& _internal_dimensions(int index) const;
  std::string* _internal_add_dimensions();
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.Dimensions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dimensions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class OrderBy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.OrderBy) */ {
 public:
  inline OrderBy() : OrderBy(nullptr) {}
  ~OrderBy() override;
  explicit PROTOBUF_CONSTEXPR OrderBy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderBy(const OrderBy& from);
  OrderBy(OrderBy&& from) noexcept
    : OrderBy() {
    *this = ::std::move(from);
  }

  inline OrderBy& operator=(const OrderBy& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderBy& operator=(OrderBy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderBy& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderBy* internal_default_instance() {
    return reinterpret_cast<const OrderBy*>(
               &_OrderBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OrderBy& a, OrderBy& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderBy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderBy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderBy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderBy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderBy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderBy& from) {
    OrderBy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderBy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.OrderBy";
  }
  protected:
  explicit OrderBy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByFieldNumber = 1,
    kReverseFieldNumber = 2,
    kCaseSensitiveFieldNumber = 3,
  };
  // string by = 1;
  void clear_by();
  const std::string& by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_by();
  PROTOBUF_NODISCARD std::string* release_by();
  void set_allocated_by(std::string* by);
  private:
  const std::string& _internal_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_by(const std::string& value);
  std::string* _internal_mutable_by();
  public:

  // bool reverse = 2;
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // bool case_sensitive = 3;
  void clear_case_sensitive();
  bool case_sensitive() const;
  void set_case_sensitive(bool value);
  private:
  bool _internal_case_sensitive() const;
  void _internal_set_case_sensitive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.OrderBy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr by_;
    bool reverse_;
    bool case_sensitive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class Metric final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.Metric) */ {
 public:
  inline Metric() : Metric(nullptr) {}
  ~Metric() override;
  explicit PROTOBUF_CONSTEXPR Metric(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metric(const Metric& from);
  Metric(Metric&& from) noexcept
    : Metric() {
    *this = ::std::move(from);
  }

  inline Metric& operator=(const Metric& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metric& operator=(Metric&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metric& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metric* internal_default_instance() {
    return reinterpret_cast<const Metric*>(
               &_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Metric& a, Metric& b) {
    a.Swap(&b);
  }
  inline void Swap(Metric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metric* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metric* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metric>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metric& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metric& from) {
    Metric::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metric* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.Metric";
  }
  protected:
  explicit Metric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfFieldNumber = 2,
    kAsFieldNumber = 3,
    kNameFieldNumber = 4,
    kFunctionFieldNumber = 1,
  };
  // string of = 2;
  void clear_of();
  const std::string& of() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_of(ArgT0&& arg0, ArgT... args);
  std::string* mutable_of();
  PROTOBUF_NODISCARD std::string* release_of();
  void set_allocated_of(std::string* of);
  private:
  const std::string& _internal_of() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_of(const std::string& value);
  std::string* _internal_mutable_of();
  public:

  // string as = 3;
  void clear_as();
  const std::string& as() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_as(ArgT0&& arg0, ArgT... args);
  std::string* mutable_as();
  PROTOBUF_NODISCARD std::string* release_as();
  void set_allocated_as(std::string* as);
  private:
  const std::string& _internal_as() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_as(const std::string& value);
  std::string* _internal_mutable_as();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .com.isima.bios.models.proto.MetricFunction function = 1;
  void clear_function();
  ::com::isima::bios::models::proto::MetricFunction function() const;
  void set_function(::com::isima::bios::models::proto::MetricFunction value);
  private:
  ::com::isima::bios::models::proto::MetricFunction _internal_function() const;
  void _internal_set_function(::com::isima::bios::models::proto::MetricFunction value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.Metric)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr of_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr as_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int function_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class ColumnDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.ColumnDefinition) */ {
 public:
  inline ColumnDefinition() : ColumnDefinition(nullptr) {}
  ~ColumnDefinition() override;
  explicit PROTOBUF_CONSTEXPR ColumnDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDefinition(const ColumnDefinition& from);
  ColumnDefinition(ColumnDefinition&& from) noexcept
    : ColumnDefinition() {
    *this = ::std::move(from);
  }

  inline ColumnDefinition& operator=(const ColumnDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDefinition& operator=(ColumnDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnDefinition* internal_default_instance() {
    return reinterpret_cast<const ColumnDefinition*>(
               &_ColumnDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ColumnDefinition& a, ColumnDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDefinition& from) {
    ColumnDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.ColumnDefinition";
  }
  protected:
  explicit ColumnDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIndexInValueArrayFieldNumber = 3,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .com.isima.bios.models.proto.AttributeType type = 1;
  void clear_type();
  ::com::isima::bios::models::proto::AttributeType type() const;
  void set_type(::com::isima::bios::models::proto::AttributeType value);
  private:
  ::com::isima::bios::models::proto::AttributeType _internal_type() const;
  void _internal_set_type(::com::isima::bios::models::proto::AttributeType value);
  public:

  // int32 index_in_value_array = 3;
  void clear_index_in_value_array();
  int32_t index_in_value_array() const;
  void set_index_in_value_array(int32_t value);
  private:
  int32_t _internal_index_in_value_array() const;
  void _internal_set_index_in_value_array(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.ColumnDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    int32_t index_in_value_array_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class AttributeList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.AttributeList) */ {
 public:
  inline AttributeList() : AttributeList(nullptr) {}
  ~AttributeList() override;
  explicit PROTOBUF_CONSTEXPR AttributeList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttributeList(const AttributeList& from);
  AttributeList(AttributeList&& from) noexcept
    : AttributeList() {
    *this = ::std::move(from);
  }

  inline AttributeList& operator=(const AttributeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeList& operator=(AttributeList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributeList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttributeList* internal_default_instance() {
    return reinterpret_cast<const AttributeList*>(
               &_AttributeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AttributeList& a, AttributeList& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributeList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttributeList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttributeList& from) {
    AttributeList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.AttributeList";
  }
  protected:
  explicit AttributeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 1,
  };
  // repeated string attributes = 1;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  const std::string& attributes(int index) const;
  std::string* mutable_attributes(int index);
  void set_attributes(int index, const std::string& value);
  void set_attributes(int index, std::string&& value);
  void set_attributes(int index, const char* value);
  void set_attributes(int index, const char* value, size_t size);
  std::string* add_attributes();
  void add_attributes(const std::string& value);
  void add_attributes(std::string&& value);
  void add_attributes(const char* value);
  void add_attributes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attributes();
  private:
  const std::string& _internal_attributes(int index) const;
  std::string* _internal_add_attributes();
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.AttributeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attributes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class Record final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.Record) */ {
 public:
  inline Record() : Record(nullptr) {}
  ~Record() override;
  explicit PROTOBUF_CONSTEXPR Record(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Record(const Record& from);
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Record& operator=(Record&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Record& default_instance() {
    return *internal_default_instance();
  }
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }
  inline void Swap(Record* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Record& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Record& from) {
    Record::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.Record";
  }
  protected:
  explicit Record(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongValuesFieldNumber = 10,
    kDoubleValuesFieldNumber = 11,
    kStringValuesFieldNumber = 12,
    kBlobValuesFieldNumber = 13,
    kBooleanValuesFieldNumber = 14,
    kEventIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated int64 long_values = 10;
  int long_values_size() const;
  private:
  int _internal_long_values_size() const;
  public:
  void clear_long_values();
  private:
  int64_t _internal_long_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_long_values() const;
  void _internal_add_long_values(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_long_values();
  public:
  int64_t long_values(int index) const;
  void set_long_values(int index, int64_t value);
  void add_long_values(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      long_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_long_values();

  // repeated double double_values = 11;
  int double_values_size() const;
  private:
  int _internal_double_values_size() const;
  public:
  void clear_double_values();
  private:
  double _internal_double_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_double_values() const;
  void _internal_add_double_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_double_values();
  public:
  double double_values(int index) const;
  void set_double_values(int index, double value);
  void add_double_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      double_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_double_values();

  // repeated string string_values = 12;
  int string_values_size() const;
  private:
  int _internal_string_values_size() const;
  public:
  void clear_string_values();
  const std::string& string_values(int index) const;
  std::string* mutable_string_values(int index);
  void set_string_values(int index, const std::string& value);
  void set_string_values(int index, std::string&& value);
  void set_string_values(int index, const char* value);
  void set_string_values(int index, const char* value, size_t size);
  std::string* add_string_values();
  void add_string_values(const std::string& value);
  void add_string_values(std::string&& value);
  void add_string_values(const char* value);
  void add_string_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& string_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_string_values();
  private:
  const std::string& _internal_string_values(int index) const;
  std::string* _internal_add_string_values();
  public:

  // repeated bytes blob_values = 13;
  int blob_values_size() const;
  private:
  int _internal_blob_values_size() const;
  public:
  void clear_blob_values();
  const std::string& blob_values(int index) const;
  std::string* mutable_blob_values(int index);
  void set_blob_values(int index, const std::string& value);
  void set_blob_values(int index, std::string&& value);
  void set_blob_values(int index, const char* value);
  void set_blob_values(int index, const void* value, size_t size);
  std::string* add_blob_values();
  void add_blob_values(const std::string& value);
  void add_blob_values(std::string&& value);
  void add_blob_values(const char* value);
  void add_blob_values(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blob_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blob_values();
  private:
  const std::string& _internal_blob_values(int index) const;
  std::string* _internal_add_blob_values();
  public:

  // repeated bool boolean_values = 14;
  int boolean_values_size() const;
  private:
  int _internal_boolean_values_size() const;
  public:
  void clear_boolean_values();
  private:
  bool _internal_boolean_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_boolean_values() const;
  void _internal_add_boolean_values(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_boolean_values();
  public:
  bool boolean_values(int index) const;
  void set_boolean_values(int index, bool value);
  void add_boolean_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      boolean_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_boolean_values();

  // bytes event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.Record)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > long_values_;
    mutable std::atomic<int> _long_values_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > double_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> string_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blob_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > boolean_values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class InsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.InsertRequest) */ {
 public:
  inline InsertRequest() : InsertRequest(nullptr) {}
  ~InsertRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequest(const InsertRequest& from);
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequest& from) {
    InsertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.InsertRequest";
  }
  protected:
  explicit InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 2,
    kSchemaVersionFieldNumber = 10,
    kContentRepFieldNumber = 1,
  };
  // .com.isima.bios.models.proto.Record record = 2;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::com::isima::bios::models::proto::Record& record() const;
  PROTOBUF_NODISCARD ::com::isima::bios::models::proto::Record* release_record();
  ::com::isima::bios::models::proto::Record* mutable_record();
  void set_allocated_record(::com::isima::bios::models::proto::Record* record);
  private:
  const ::com::isima::bios::models::proto::Record& _internal_record() const;
  ::com::isima::bios::models::proto::Record* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::com::isima::bios::models::proto::Record* record);
  ::com::isima::bios::models::proto::Record* unsafe_arena_release_record();

  // int64 schema_version = 10;
  void clear_schema_version();
  int64_t schema_version() const;
  void set_schema_version(int64_t value);
  private:
  int64_t _internal_schema_version() const;
  void _internal_set_schema_version(int64_t value);
  public:

  // .com.isima.bios.models.proto.ContentRepresentation content_rep = 1;
  void clear_content_rep();
  ::com::isima::bios::models::proto::ContentRepresentation content_rep() const;
  void set_content_rep(::com::isima::bios::models::proto::ContentRepresentation value);
  private:
  ::com::isima::bios::models::proto::ContentRepresentation _internal_content_rep() const;
  void _internal_set_content_rep(::com::isima::bios::models::proto::ContentRepresentation value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.InsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::com::isima::bios::models::proto::Record* record_;
    int64_t schema_version_;
    int content_rep_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class InsertSuccessResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.InsertSuccessResponse) */ {
 public:
  inline InsertSuccessResponse() : InsertSuccessResponse(nullptr) {}
  ~InsertSuccessResponse() override;
  explicit PROTOBUF_CONSTEXPR InsertSuccessResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertSuccessResponse(const InsertSuccessResponse& from);
  InsertSuccessResponse(InsertSuccessResponse&& from) noexcept
    : InsertSuccessResponse() {
    *this = ::std::move(from);
  }

  inline InsertSuccessResponse& operator=(const InsertSuccessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertSuccessResponse& operator=(InsertSuccessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertSuccessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertSuccessResponse* internal_default_instance() {
    return reinterpret_cast<const InsertSuccessResponse*>(
               &_InsertSuccessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InsertSuccessResponse& a, InsertSuccessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertSuccessResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertSuccessResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertSuccessResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertSuccessResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertSuccessResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertSuccessResponse& from) {
    InsertSuccessResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertSuccessResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.InsertSuccessResponse";
  }
  protected:
  explicit InsertSuccessResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kInsertTimestampFieldNumber = 2,
  };
  // bytes event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // int64 insert_timestamp = 2;
  void clear_insert_timestamp();
  int64_t insert_timestamp() const;
  void set_insert_timestamp(int64_t value);
  private:
  int64_t _internal_insert_timestamp() const;
  void _internal_set_insert_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.InsertSuccessResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    int64_t insert_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class InsertBulkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.InsertBulkRequest) */ {
 public:
  inline InsertBulkRequest() : InsertBulkRequest(nullptr) {}
  ~InsertBulkRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertBulkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertBulkRequest(const InsertBulkRequest& from);
  InsertBulkRequest(InsertBulkRequest&& from) noexcept
    : InsertBulkRequest() {
    *this = ::std::move(from);
  }

  inline InsertBulkRequest& operator=(const InsertBulkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertBulkRequest& operator=(InsertBulkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertBulkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertBulkRequest* internal_default_instance() {
    return reinterpret_cast<const InsertBulkRequest*>(
               &_InsertBulkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InsertBulkRequest& a, InsertBulkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertBulkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertBulkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertBulkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertBulkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertBulkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertBulkRequest& from) {
    InsertBulkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertBulkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.InsertBulkRequest";
  }
  protected:
  explicit InsertBulkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 2,
    kSignalFieldNumber = 5,
    kSchemaVersionFieldNumber = 10,
    kContentRepFieldNumber = 1,
  };
  // repeated .com.isima.bios.models.proto.Record record = 2;
  int record_size() const;
  private:
  int _internal_record_size() const;
  public:
  void clear_record();
  ::com::isima::bios::models::proto::Record* mutable_record(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record >*
      mutable_record();
  private:
  const ::com::isima::bios::models::proto::Record& _internal_record(int index) const;
  ::com::isima::bios::models::proto::Record* _internal_add_record();
  public:
  const ::com::isima::bios::models::proto::Record& record(int index) const;
  ::com::isima::bios::models::proto::Record* add_record();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record >&
      record() const;

  // string signal = 5;
  void clear_signal();
  const std::string& signal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signal();
  PROTOBUF_NODISCARD std::string* release_signal();
  void set_allocated_signal(std::string* signal);
  private:
  const std::string& _internal_signal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signal(const std::string& value);
  std::string* _internal_mutable_signal();
  public:

  // int64 schema_version = 10;
  void clear_schema_version();
  int64_t schema_version() const;
  void set_schema_version(int64_t value);
  private:
  int64_t _internal_schema_version() const;
  void _internal_set_schema_version(int64_t value);
  public:

  // .com.isima.bios.models.proto.ContentRepresentation content_rep = 1;
  void clear_content_rep();
  ::com::isima::bios::models::proto::ContentRepresentation content_rep() const;
  void set_content_rep(::com::isima::bios::models::proto::ContentRepresentation value);
  private:
  ::com::isima::bios::models::proto::ContentRepresentation _internal_content_rep() const;
  void _internal_set_content_rep(::com::isima::bios::models::proto::ContentRepresentation value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.InsertBulkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record > record_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signal_;
    int64_t schema_version_;
    int content_rep_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class InsertBulkSuccessResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.InsertBulkSuccessResponse) */ {
 public:
  inline InsertBulkSuccessResponse() : InsertBulkSuccessResponse(nullptr) {}
  ~InsertBulkSuccessResponse() override;
  explicit PROTOBUF_CONSTEXPR InsertBulkSuccessResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertBulkSuccessResponse(const InsertBulkSuccessResponse& from);
  InsertBulkSuccessResponse(InsertBulkSuccessResponse&& from) noexcept
    : InsertBulkSuccessResponse() {
    *this = ::std::move(from);
  }

  inline InsertBulkSuccessResponse& operator=(const InsertBulkSuccessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertBulkSuccessResponse& operator=(InsertBulkSuccessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertBulkSuccessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertBulkSuccessResponse* internal_default_instance() {
    return reinterpret_cast<const InsertBulkSuccessResponse*>(
               &_InsertBulkSuccessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InsertBulkSuccessResponse& a, InsertBulkSuccessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertBulkSuccessResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertBulkSuccessResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertBulkSuccessResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertBulkSuccessResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertBulkSuccessResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertBulkSuccessResponse& from) {
    InsertBulkSuccessResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertBulkSuccessResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.InsertBulkSuccessResponse";
  }
  protected:
  explicit InsertBulkSuccessResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 1,
  };
  // repeated .com.isima.bios.models.proto.InsertSuccessResponse responses = 1;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::com::isima::bios::models::proto::InsertSuccessResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessResponse >*
      mutable_responses();
  private:
  const ::com::isima::bios::models::proto::InsertSuccessResponse& _internal_responses(int index) const;
  ::com::isima::bios::models::proto::InsertSuccessResponse* _internal_add_responses();
  public:
  const ::com::isima::bios::models::proto::InsertSuccessResponse& responses(int index) const;
  ::com::isima::bios::models::proto::InsertSuccessResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.InsertBulkSuccessResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessResponse > responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class InsertSuccessOrError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.InsertSuccessOrError) */ {
 public:
  inline InsertSuccessOrError() : InsertSuccessOrError(nullptr) {}
  ~InsertSuccessOrError() override;
  explicit PROTOBUF_CONSTEXPR InsertSuccessOrError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertSuccessOrError(const InsertSuccessOrError& from);
  InsertSuccessOrError(InsertSuccessOrError&& from) noexcept
    : InsertSuccessOrError() {
    *this = ::std::move(from);
  }

  inline InsertSuccessOrError& operator=(const InsertSuccessOrError& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertSuccessOrError& operator=(InsertSuccessOrError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertSuccessOrError& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertSuccessOrError* internal_default_instance() {
    return reinterpret_cast<const InsertSuccessOrError*>(
               &_InsertSuccessOrError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InsertSuccessOrError& a, InsertSuccessOrError& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertSuccessOrError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertSuccessOrError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertSuccessOrError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertSuccessOrError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertSuccessOrError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertSuccessOrError& from) {
    InsertSuccessOrError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertSuccessOrError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.InsertSuccessOrError";
  }
  protected:
  explicit InsertSuccessOrError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kErrorMessageFieldNumber = 10,
    kServerErrorCodeFieldNumber = 11,
    kInsertTimestampFieldNumber = 2,
  };
  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string error_message = 10;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string server_error_code = 11;
  void clear_server_error_code();
  const std::string& server_error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_error_code();
  PROTOBUF_NODISCARD std::string* release_server_error_code();
  void set_allocated_server_error_code(std::string* server_error_code);
  private:
  const std::string& _internal_server_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_error_code(const std::string& value);
  std::string* _internal_mutable_server_error_code();
  public:

  // int64 insert_timestamp = 2;
  void clear_insert_timestamp();
  int64_t insert_timestamp() const;
  void set_insert_timestamp(int64_t value);
  private:
  int64_t _internal_insert_timestamp() const;
  void _internal_set_insert_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.InsertSuccessOrError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_error_code_;
    int64_t insert_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class InsertBulkErrorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.InsertBulkErrorResponse) */ {
 public:
  inline InsertBulkErrorResponse() : InsertBulkErrorResponse(nullptr) {}
  ~InsertBulkErrorResponse() override;
  explicit PROTOBUF_CONSTEXPR InsertBulkErrorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertBulkErrorResponse(const InsertBulkErrorResponse& from);
  InsertBulkErrorResponse(InsertBulkErrorResponse&& from) noexcept
    : InsertBulkErrorResponse() {
    *this = ::std::move(from);
  }

  inline InsertBulkErrorResponse& operator=(const InsertBulkErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertBulkErrorResponse& operator=(InsertBulkErrorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertBulkErrorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertBulkErrorResponse* internal_default_instance() {
    return reinterpret_cast<const InsertBulkErrorResponse*>(
               &_InsertBulkErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InsertBulkErrorResponse& a, InsertBulkErrorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertBulkErrorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertBulkErrorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertBulkErrorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertBulkErrorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertBulkErrorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertBulkErrorResponse& from) {
    InsertBulkErrorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertBulkErrorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.InsertBulkErrorResponse";
  }
  protected:
  explicit InsertBulkErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsWithErrorFieldNumber = 4,
    kServerErrorCodeFieldNumber = 1,
    kServerErrorMessageFieldNumber = 2,
  };
  // repeated .com.isima.bios.models.proto.InsertSuccessOrError results_with_error = 4;
  int results_with_error_size() const;
  private:
  int _internal_results_with_error_size() const;
  public:
  void clear_results_with_error();
  ::com::isima::bios::models::proto::InsertSuccessOrError* mutable_results_with_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessOrError >*
      mutable_results_with_error();
  private:
  const ::com::isima::bios::models::proto::InsertSuccessOrError& _internal_results_with_error(int index) const;
  ::com::isima::bios::models::proto::InsertSuccessOrError* _internal_add_results_with_error();
  public:
  const ::com::isima::bios::models::proto::InsertSuccessOrError& results_with_error(int index) const;
  ::com::isima::bios::models::proto::InsertSuccessOrError* add_results_with_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessOrError >&
      results_with_error() const;

  // string server_error_code = 1;
  void clear_server_error_code();
  const std::string& server_error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_error_code();
  PROTOBUF_NODISCARD std::string* release_server_error_code();
  void set_allocated_server_error_code(std::string* server_error_code);
  private:
  const std::string& _internal_server_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_error_code(const std::string& value);
  std::string* _internal_mutable_server_error_code();
  public:

  // string server_error_message = 2;
  void clear_server_error_message();
  const std::string& server_error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_error_message();
  PROTOBUF_NODISCARD std::string* release_server_error_message();
  void set_allocated_server_error_message(std::string* server_error_message);
  private:
  const std::string& _internal_server_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_error_message(const std::string& value);
  std::string* _internal_mutable_server_error_message();
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.InsertBulkErrorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessOrError > results_with_error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_error_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class SlidingWindow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.SlidingWindow) */ {
 public:
  inline SlidingWindow() : SlidingWindow(nullptr) {}
  ~SlidingWindow() override;
  explicit PROTOBUF_CONSTEXPR SlidingWindow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SlidingWindow(const SlidingWindow& from);
  SlidingWindow(SlidingWindow&& from) noexcept
    : SlidingWindow() {
    *this = ::std::move(from);
  }

  inline SlidingWindow& operator=(const SlidingWindow& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlidingWindow& operator=(SlidingWindow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SlidingWindow& default_instance() {
    return *internal_default_instance();
  }
  static inline const SlidingWindow* internal_default_instance() {
    return reinterpret_cast<const SlidingWindow*>(
               &_SlidingWindow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SlidingWindow& a, SlidingWindow& b) {
    a.Swap(&b);
  }
  inline void Swap(SlidingWindow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlidingWindow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SlidingWindow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SlidingWindow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SlidingWindow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SlidingWindow& from) {
    SlidingWindow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SlidingWindow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.SlidingWindow";
  }
  protected:
  explicit SlidingWindow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlideIntervalFieldNumber = 1,
    kWindowSlidesFieldNumber = 2,
  };
  // int64 slide_interval = 1;
  void clear_slide_interval();
  int64_t slide_interval() const;
  void set_slide_interval(int64_t value);
  private:
  int64_t _internal_slide_interval() const;
  void _internal_set_slide_interval(int64_t value);
  public:

  // int32 window_slides = 2;
  void clear_window_slides();
  int32_t window_slides() const;
  void set_window_slides(int32_t value);
  private:
  int32_t _internal_window_slides() const;
  void _internal_set_window_slides(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.SlidingWindow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t slide_interval_;
    int32_t window_slides_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class TumblingWindow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.TumblingWindow) */ {
 public:
  inline TumblingWindow() : TumblingWindow(nullptr) {}
  ~TumblingWindow() override;
  explicit PROTOBUF_CONSTEXPR TumblingWindow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TumblingWindow(const TumblingWindow& from);
  TumblingWindow(TumblingWindow&& from) noexcept
    : TumblingWindow() {
    *this = ::std::move(from);
  }

  inline TumblingWindow& operator=(const TumblingWindow& from) {
    CopyFrom(from);
    return *this;
  }
  inline TumblingWindow& operator=(TumblingWindow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TumblingWindow& default_instance() {
    return *internal_default_instance();
  }
  static inline const TumblingWindow* internal_default_instance() {
    return reinterpret_cast<const TumblingWindow*>(
               &_TumblingWindow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TumblingWindow& a, TumblingWindow& b) {
    a.Swap(&b);
  }
  inline void Swap(TumblingWindow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TumblingWindow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TumblingWindow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TumblingWindow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TumblingWindow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TumblingWindow& from) {
    TumblingWindow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TumblingWindow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.TumblingWindow";
  }
  protected:
  explicit TumblingWindow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowSizeMsFieldNumber = 1,
  };
  // int64 window_size_ms = 1;
  void clear_window_size_ms();
  int64_t window_size_ms() const;
  void set_window_size_ms(int64_t value);
  private:
  int64_t _internal_window_size_ms() const;
  void _internal_set_window_size_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.TumblingWindow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t window_size_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class Window final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.Window) */ {
 public:
  inline Window() : Window(nullptr) {}
  ~Window() override;
  explicit PROTOBUF_CONSTEXPR Window(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Window(const Window& from);
  Window(Window&& from) noexcept
    : Window() {
    *this = ::std::move(from);
  }

  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }
  inline Window& operator=(Window&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Window& default_instance() {
    return *internal_default_instance();
  }
  enum WindowDetailsCase {
    kSliding = 10,
    kTumbling = 11,
    WINDOW_DETAILS_NOT_SET = 0,
  };

  static inline const Window* internal_default_instance() {
    return reinterpret_cast<const Window*>(
               &_Window_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Window& a, Window& b) {
    a.Swap(&b);
  }
  inline void Swap(Window* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Window* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Window* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Window>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Window& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Window& from) {
    Window::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Window* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.Window";
  }
  protected:
  explicit Window(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowTypeFieldNumber = 1,
    kSlidingFieldNumber = 10,
    kTumblingFieldNumber = 11,
  };
  // .com.isima.bios.models.proto.WindowType window_type = 1;
  void clear_window_type();
  ::com::isima::bios::models::proto::WindowType window_type() const;
  void set_window_type(::com::isima::bios::models::proto::WindowType value);
  private:
  ::com::isima::bios::models::proto::WindowType _internal_window_type() const;
  void _internal_set_window_type(::com::isima::bios::models::proto::WindowType value);
  public:

  // .com.isima.bios.models.proto.SlidingWindow sliding = 10;
  bool has_sliding() const;
  private:
  bool _internal_has_sliding() const;
  public:
  void clear_sliding();
  const ::com::isima::bios::models::proto::SlidingWindow& sliding() const;
  PROTOBUF_NODISCARD ::com::isima::bios::models::proto::SlidingWindow* release_sliding();
  ::com::isima::bios::models::proto::SlidingWindow* mutable_sliding();
  void set_allocated_sliding(::com::isima::bios::models::proto::SlidingWindow* sliding);
  private:
  const ::com::isima::bios::models::proto::SlidingWindow& _internal_sliding() const;
  ::com::isima::bios::models::proto::SlidingWindow* _internal_mutable_sliding();
  public:
  void unsafe_arena_set_allocated_sliding(
      ::com::isima::bios::models::proto::SlidingWindow* sliding);
  ::com::isima::bios::models::proto::SlidingWindow* unsafe_arena_release_sliding();

  // .com.isima.bios.models.proto.TumblingWindow tumbling = 11;
  bool has_tumbling() const;
  private:
  bool _internal_has_tumbling() const;
  public:
  void clear_tumbling();
  const ::com::isima::bios::models::proto::TumblingWindow& tumbling() const;
  PROTOBUF_NODISCARD ::com::isima::bios::models::proto::TumblingWindow* release_tumbling();
  ::com::isima::bios::models::proto::TumblingWindow* mutable_tumbling();
  void set_allocated_tumbling(::com::isima::bios::models::proto::TumblingWindow* tumbling);
  private:
  const ::com::isima::bios::models::proto::TumblingWindow& _internal_tumbling() const;
  ::com::isima::bios::models::proto::TumblingWindow* _internal_mutable_tumbling();
  public:
  void unsafe_arena_set_allocated_tumbling(
      ::com::isima::bios::models::proto::TumblingWindow* tumbling);
  ::com::isima::bios::models::proto::TumblingWindow* unsafe_arena_release_tumbling();

  void clear_window_details();
  WindowDetailsCase window_details_case() const;
  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.Window)
 private:
  class _Internal;
  void set_has_sliding();
  void set_has_tumbling();

  inline bool has_window_details() const;
  inline void clear_has_window_details();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int window_type_;
    union WindowDetailsUnion {
      constexpr WindowDetailsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::com::isima::bios::models::proto::SlidingWindow* sliding_;
      ::com::isima::bios::models::proto::TumblingWindow* tumbling_;
    } window_details_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class SelectQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.SelectQuery) */ {
 public:
  inline SelectQuery() : SelectQuery(nullptr) {}
  ~SelectQuery() override;
  explicit PROTOBUF_CONSTEXPR SelectQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectQuery(const SelectQuery& from);
  SelectQuery(SelectQuery&& from) noexcept
    : SelectQuery() {
    *this = ::std::move(from);
  }

  inline SelectQuery& operator=(const SelectQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectQuery& operator=(SelectQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectQuery* internal_default_instance() {
    return reinterpret_cast<const SelectQuery*>(
               &_SelectQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SelectQuery& a, SelectQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectQuery& from) {
    SelectQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.SelectQuery";
  }
  protected:
  explicit SelectQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 12,
    kWindowsFieldNumber = 40,
    kFromFieldNumber = 15,
    kWhereFieldNumber = 20,
    kAttributesFieldNumber = 11,
    kGroupByFieldNumber = 30,
    kOrderByFieldNumber = 50,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kDistinctFieldNumber = 10,
    kOnTheFlyFieldNumber = 70,
    kLimitFieldNumber = 60,
  };
  // repeated .com.isima.bios.models.proto.Metric metrics = 12;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::com::isima::bios::models::proto::Metric* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Metric >*
      mutable_metrics();
  private:
  const ::com::isima::bios::models::proto::Metric& _internal_metrics(int index) const;
  ::com::isima::bios::models::proto::Metric* _internal_add_metrics();
  public:
  const ::com::isima::bios::models::proto::Metric& metrics(int index) const;
  ::com::isima::bios::models::proto::Metric* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Metric >&
      metrics() const;

  // repeated .com.isima.bios.models.proto.Window windows = 40;
  int windows_size() const;
  private:
  int _internal_windows_size() const;
  public:
  void clear_windows();
  ::com::isima::bios::models::proto::Window* mutable_windows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Window >*
      mutable_windows();
  private:
  const ::com::isima::bios::models::proto::Window& _internal_windows(int index) const;
  ::com::isima::bios::models::proto::Window* _internal_add_windows();
  public:
  const ::com::isima::bios::models::proto::Window& windows(int index) const;
  ::com::isima::bios::models::proto::Window* add_windows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Window >&
      windows() const;

  // string from = 15;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string where = 20;
  void clear_where();
  const std::string& where() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_where(ArgT0&& arg0, ArgT... args);
  std::string* mutable_where();
  PROTOBUF_NODISCARD std::string* release_where();
  void set_allocated_where(std::string* where);
  private:
  const std::string& _internal_where() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_where(const std::string& value);
  std::string* _internal_mutable_where();
  public:

  // .com.isima.bios.models.proto.AttributeList attributes = 11;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::com::isima::bios::models::proto::AttributeList& attributes() const;
  PROTOBUF_NODISCARD ::com::isima::bios::models::proto::AttributeList* release_attributes();
  ::com::isima::bios::models::proto::AttributeList* mutable_attributes();
  void set_allocated_attributes(::com::isima::bios::models::proto::AttributeList* attributes);
  private:
  const ::com::isima::bios::models::proto::AttributeList& _internal_attributes() const;
  ::com::isima::bios::models::proto::AttributeList* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::com::isima::bios::models::proto::AttributeList* attributes);
  ::com::isima::bios::models::proto::AttributeList* unsafe_arena_release_attributes();

  // .com.isima.bios.models.proto.Dimensions group_by = 30;
  bool has_group_by() const;
  private:
  bool _internal_has_group_by() const;
  public:
  void clear_group_by();
  const ::com::isima::bios::models::proto::Dimensions& group_by() const;
  PROTOBUF_NODISCARD ::com::isima::bios::models::proto::Dimensions* release_group_by();
  ::com::isima::bios::models::proto::Dimensions* mutable_group_by();
  void set_allocated_group_by(::com::isima::bios::models::proto::Dimensions* group_by);
  private:
  const ::com::isima::bios::models::proto::Dimensions& _internal_group_by() const;
  ::com::isima::bios::models::proto::Dimensions* _internal_mutable_group_by();
  public:
  void unsafe_arena_set_allocated_group_by(
      ::com::isima::bios::models::proto::Dimensions* group_by);
  ::com::isima::bios::models::proto::Dimensions* unsafe_arena_release_group_by();

  // .com.isima.bios.models.proto.OrderBy order_by = 50;
  bool has_order_by() const;
  private:
  bool _internal_has_order_by() const;
  public:
  void clear_order_by();
  const ::com::isima::bios::models::proto::OrderBy& order_by() const;
  PROTOBUF_NODISCARD ::com::isima::bios::models::proto::OrderBy* release_order_by();
  ::com::isima::bios::models::proto::OrderBy* mutable_order_by();
  void set_allocated_order_by(::com::isima::bios::models::proto::OrderBy* order_by);
  private:
  const ::com::isima::bios::models::proto::OrderBy& _internal_order_by() const;
  ::com::isima::bios::models::proto::OrderBy* _internal_mutable_order_by();
  public:
  void unsafe_arena_set_allocated_order_by(
      ::com::isima::bios::models::proto::OrderBy* order_by);
  ::com::isima::bios::models::proto::OrderBy* unsafe_arena_release_order_by();

  // int64 start_time = 1;
  void clear_start_time();
  int64_t start_time() const;
  void set_start_time(int64_t value);
  private:
  int64_t _internal_start_time() const;
  void _internal_set_start_time(int64_t value);
  public:

  // int64 end_time = 2;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // bool distinct = 10;
  void clear_distinct();
  bool distinct() const;
  void set_distinct(bool value);
  private:
  bool _internal_distinct() const;
  void _internal_set_distinct(bool value);
  public:

  // bool on_the_fly = 70;
  void clear_on_the_fly();
  bool on_the_fly() const;
  void set_on_the_fly(bool value);
  private:
  bool _internal_on_the_fly() const;
  void _internal_set_on_the_fly(bool value);
  public:

  // optional int32 limit = 60;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.SelectQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Metric > metrics_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Window > windows_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr where_;
    ::com::isima::bios::models::proto::AttributeList* attributes_;
    ::com::isima::bios::models::proto::Dimensions* group_by_;
    ::com::isima::bios::models::proto::OrderBy* order_by_;
    int64_t start_time_;
    int64_t end_time_;
    bool distinct_;
    bool on_the_fly_;
    int32_t limit_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class SelectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.SelectRequest) */ {
 public:
  inline SelectRequest() : SelectRequest(nullptr) {}
  ~SelectRequest() override;
  explicit PROTOBUF_CONSTEXPR SelectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectRequest(const SelectRequest& from);
  SelectRequest(SelectRequest&& from) noexcept
    : SelectRequest() {
    *this = ::std::move(from);
  }

  inline SelectRequest& operator=(const SelectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectRequest& operator=(SelectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectRequest* internal_default_instance() {
    return reinterpret_cast<const SelectRequest*>(
               &_SelectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SelectRequest& a, SelectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectRequest& from) {
    SelectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.SelectRequest";
  }
  protected:
  explicit SelectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueriesFieldNumber = 1,
  };
  // repeated .com.isima.bios.models.proto.SelectQuery queries = 1;
  int queries_size() const;
  private:
  int _internal_queries_size() const;
  public:
  void clear_queries();
  ::com::isima::bios::models::proto::SelectQuery* mutable_queries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQuery >*
      mutable_queries();
  private:
  const ::com::isima::bios::models::proto::SelectQuery& _internal_queries(int index) const;
  ::com::isima::bios::models::proto::SelectQuery* _internal_add_queries();
  public:
  const ::com::isima::bios::models::proto::SelectQuery& queries(int index) const;
  ::com::isima::bios::models::proto::SelectQuery* add_queries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQuery >&
      queries() const;

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.SelectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQuery > queries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class QueryResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.QueryResult) */ {
 public:
  inline QueryResult() : QueryResult(nullptr) {}
  ~QueryResult() override;
  explicit PROTOBUF_CONSTEXPR QueryResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryResult(const QueryResult& from);
  QueryResult(QueryResult&& from) noexcept
    : QueryResult() {
    *this = ::std::move(from);
  }

  inline QueryResult& operator=(const QueryResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryResult& operator=(QueryResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryResult* internal_default_instance() {
    return reinterpret_cast<const QueryResult*>(
               &_QueryResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(QueryResult& a, QueryResult& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryResult& from) {
    QueryResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.QueryResult";
  }
  protected:
  explicit QueryResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 10,
    kWindowBeginTimeFieldNumber = 1,
  };
  // repeated .com.isima.bios.models.proto.Record records = 10;
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  ::com::isima::bios::models::proto::Record* mutable_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record >*
      mutable_records();
  private:
  const ::com::isima::bios::models::proto::Record& _internal_records(int index) const;
  ::com::isima::bios::models::proto::Record* _internal_add_records();
  public:
  const ::com::isima::bios::models::proto::Record& records(int index) const;
  ::com::isima::bios::models::proto::Record* add_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record >&
      records() const;

  // int64 window_begin_time = 1;
  void clear_window_begin_time();
  int64_t window_begin_time() const;
  void set_window_begin_time(int64_t value);
  private:
  int64_t _internal_window_begin_time() const;
  void _internal_set_window_begin_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.QueryResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record > records_;
    int64_t window_begin_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class SelectQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.SelectQueryResponse) */ {
 public:
  inline SelectQueryResponse() : SelectQueryResponse(nullptr) {}
  ~SelectQueryResponse() override;
  explicit PROTOBUF_CONSTEXPR SelectQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectQueryResponse(const SelectQueryResponse& from);
  SelectQueryResponse(SelectQueryResponse&& from) noexcept
    : SelectQueryResponse() {
    *this = ::std::move(from);
  }

  inline SelectQueryResponse& operator=(const SelectQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectQueryResponse& operator=(SelectQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectQueryResponse* internal_default_instance() {
    return reinterpret_cast<const SelectQueryResponse*>(
               &_SelectQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SelectQueryResponse& a, SelectQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectQueryResponse& from) {
    SelectQueryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.SelectQueryResponse";
  }
  protected:
  explicit SelectQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kDefinitionsFieldNumber = 2,
    kIsWindowedResponseFieldNumber = 3,
    kRequestQueryNumFieldNumber = 4,
  };
  // repeated .com.isima.bios.models.proto.QueryResult data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::com::isima::bios::models::proto::QueryResult* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::QueryResult >*
      mutable_data();
  private:
  const ::com::isima::bios::models::proto::QueryResult& _internal_data(int index) const;
  ::com::isima::bios::models::proto::QueryResult* _internal_add_data();
  public:
  const ::com::isima::bios::models::proto::QueryResult& data(int index) const;
  ::com::isima::bios::models::proto::QueryResult* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::QueryResult >&
      data() const;

  // repeated .com.isima.bios.models.proto.ColumnDefinition definitions = 2;
  int definitions_size() const;
  private:
  int _internal_definitions_size() const;
  public:
  void clear_definitions();
  ::com::isima::bios::models::proto::ColumnDefinition* mutable_definitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::ColumnDefinition >*
      mutable_definitions();
  private:
  const ::com::isima::bios::models::proto::ColumnDefinition& _internal_definitions(int index) const;
  ::com::isima::bios::models::proto::ColumnDefinition* _internal_add_definitions();
  public:
  const ::com::isima::bios::models::proto::ColumnDefinition& definitions(int index) const;
  ::com::isima::bios::models::proto::ColumnDefinition* add_definitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::ColumnDefinition >&
      definitions() const;

  // bool is_windowed_response = 3;
  void clear_is_windowed_response();
  bool is_windowed_response() const;
  void set_is_windowed_response(bool value);
  private:
  bool _internal_is_windowed_response() const;
  void _internal_set_is_windowed_response(bool value);
  public:

  // int32 request_query_num = 4;
  void clear_request_query_num();
  int32_t request_query_num() const;
  void set_request_query_num(int32_t value);
  private:
  int32_t _internal_request_query_num() const;
  void _internal_set_request_query_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.SelectQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::QueryResult > data_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::ColumnDefinition > definitions_;
    bool is_windowed_response_;
    int32_t request_query_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// -------------------------------------------------------------------

class SelectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.isima.bios.models.proto.SelectResponse) */ {
 public:
  inline SelectResponse() : SelectResponse(nullptr) {}
  ~SelectResponse() override;
  explicit PROTOBUF_CONSTEXPR SelectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectResponse(const SelectResponse& from);
  SelectResponse(SelectResponse&& from) noexcept
    : SelectResponse() {
    *this = ::std::move(from);
  }

  inline SelectResponse& operator=(const SelectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectResponse& operator=(SelectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectResponse* internal_default_instance() {
    return reinterpret_cast<const SelectResponse*>(
               &_SelectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SelectResponse& a, SelectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectResponse& from) {
    SelectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.isima.bios.models.proto.SelectResponse";
  }
  protected:
  explicit SelectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 1,
  };
  // repeated .com.isima.bios.models.proto.SelectQueryResponse responses = 1;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::com::isima::bios::models::proto::SelectQueryResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQueryResponse >*
      mutable_responses();
  private:
  const ::com::isima::bios::models::proto::SelectQueryResponse& _internal_responses(int index) const;
  ::com::isima::bios::models::proto::SelectQueryResponse* _internal_add_responses();
  public:
  const ::com::isima::bios::models::proto::SelectQueryResponse& responses(int index) const;
  ::com::isima::bios::models::proto::SelectQueryResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQueryResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:com.isima.bios.models.proto.SelectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQueryResponse > responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct__5fbios_2fdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Uuid

// uint64 hi = 1;
inline void Uuid::clear_hi() {
  _impl_.hi_ = uint64_t{0u};
}
inline uint64_t Uuid::_internal_hi() const {
  return _impl_.hi_;
}
inline uint64_t Uuid::hi() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Uuid.hi)
  return _internal_hi();
}
inline void Uuid::_internal_set_hi(uint64_t value) {
  
  _impl_.hi_ = value;
}
inline void Uuid::set_hi(uint64_t value) {
  _internal_set_hi(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Uuid.hi)
}

// uint64 lo = 2;
inline void Uuid::clear_lo() {
  _impl_.lo_ = uint64_t{0u};
}
inline uint64_t Uuid::_internal_lo() const {
  return _impl_.lo_;
}
inline uint64_t Uuid::lo() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Uuid.lo)
  return _internal_lo();
}
inline void Uuid::_internal_set_lo(uint64_t value) {
  
  _impl_.lo_ = value;
}
inline void Uuid::set_lo(uint64_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Uuid.lo)
}

// -------------------------------------------------------------------

// Dimensions

// repeated string dimensions = 1;
inline int Dimensions::_internal_dimensions_size() const {
  return _impl_.dimensions_.size();
}
inline int Dimensions::dimensions_size() const {
  return _internal_dimensions_size();
}
inline void Dimensions::clear_dimensions() {
  _impl_.dimensions_.Clear();
}
inline std::string* Dimensions::add_dimensions() {
  std::string* _s = _internal_add_dimensions();
  // @@protoc_insertion_point(field_add_mutable:com.isima.bios.models.proto.Dimensions.dimensions)
  return _s;
}
inline const std::string& Dimensions::_internal_dimensions(int index) const {
  return _impl_.dimensions_.Get(index);
}
inline const std::string& Dimensions::dimensions(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Dimensions.dimensions)
  return _internal_dimensions(index);
}
inline std::string* Dimensions::mutable_dimensions(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Dimensions.dimensions)
  return _impl_.dimensions_.Mutable(index);
}
inline void Dimensions::set_dimensions(int index, const std::string& value) {
  _impl_.dimensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Dimensions.dimensions)
}
inline void Dimensions::set_dimensions(int index, std::string&& value) {
  _impl_.dimensions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Dimensions.dimensions)
}
inline void Dimensions::set_dimensions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dimensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.isima.bios.models.proto.Dimensions.dimensions)
}
inline void Dimensions::set_dimensions(int index, const char* value, size_t size) {
  _impl_.dimensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.isima.bios.models.proto.Dimensions.dimensions)
}
inline std::string* Dimensions::_internal_add_dimensions() {
  return _impl_.dimensions_.Add();
}
inline void Dimensions::add_dimensions(const std::string& value) {
  _impl_.dimensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Dimensions.dimensions)
}
inline void Dimensions::add_dimensions(std::string&& value) {
  _impl_.dimensions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Dimensions.dimensions)
}
inline void Dimensions::add_dimensions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dimensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.isima.bios.models.proto.Dimensions.dimensions)
}
inline void Dimensions::add_dimensions(const char* value, size_t size) {
  _impl_.dimensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.isima.bios.models.proto.Dimensions.dimensions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Dimensions::dimensions() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.Dimensions.dimensions)
  return _impl_.dimensions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Dimensions::mutable_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.Dimensions.dimensions)
  return &_impl_.dimensions_;
}

// -------------------------------------------------------------------

// OrderBy

// string by = 1;
inline void OrderBy::clear_by() {
  _impl_.by_.ClearToEmpty();
}
inline const std::string& OrderBy::by() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.OrderBy.by)
  return _internal_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderBy::set_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.OrderBy.by)
}
inline std::string* OrderBy::mutable_by() {
  std::string* _s = _internal_mutable_by();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.OrderBy.by)
  return _s;
}
inline const std::string& OrderBy::_internal_by() const {
  return _impl_.by_.Get();
}
inline void OrderBy::_internal_set_by(const std::string& value) {
  
  _impl_.by_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderBy::_internal_mutable_by() {
  
  return _impl_.by_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderBy::release_by() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.OrderBy.by)
  return _impl_.by_.Release();
}
inline void OrderBy::set_allocated_by(std::string* by) {
  if (by != nullptr) {
    
  } else {
    
  }
  _impl_.by_.SetAllocated(by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.by_.IsDefault()) {
    _impl_.by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.OrderBy.by)
}

// bool reverse = 2;
inline void OrderBy::clear_reverse() {
  _impl_.reverse_ = false;
}
inline bool OrderBy::_internal_reverse() const {
  return _impl_.reverse_;
}
inline bool OrderBy::reverse() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.OrderBy.reverse)
  return _internal_reverse();
}
inline void OrderBy::_internal_set_reverse(bool value) {
  
  _impl_.reverse_ = value;
}
inline void OrderBy::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.OrderBy.reverse)
}

// bool case_sensitive = 3;
inline void OrderBy::clear_case_sensitive() {
  _impl_.case_sensitive_ = false;
}
inline bool OrderBy::_internal_case_sensitive() const {
  return _impl_.case_sensitive_;
}
inline bool OrderBy::case_sensitive() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.OrderBy.case_sensitive)
  return _internal_case_sensitive();
}
inline void OrderBy::_internal_set_case_sensitive(bool value) {
  
  _impl_.case_sensitive_ = value;
}
inline void OrderBy::set_case_sensitive(bool value) {
  _internal_set_case_sensitive(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.OrderBy.case_sensitive)
}

// -------------------------------------------------------------------

// Metric

// .com.isima.bios.models.proto.MetricFunction function = 1;
inline void Metric::clear_function() {
  _impl_.function_ = 0;
}
inline ::com::isima::bios::models::proto::MetricFunction Metric::_internal_function() const {
  return static_cast< ::com::isima::bios::models::proto::MetricFunction >(_impl_.function_);
}
inline ::com::isima::bios::models::proto::MetricFunction Metric::function() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Metric.function)
  return _internal_function();
}
inline void Metric::_internal_set_function(::com::isima::bios::models::proto::MetricFunction value) {
  
  _impl_.function_ = value;
}
inline void Metric::set_function(::com::isima::bios::models::proto::MetricFunction value) {
  _internal_set_function(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Metric.function)
}

// string of = 2;
inline void Metric::clear_of() {
  _impl_.of_.ClearToEmpty();
}
inline const std::string& Metric::of() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Metric.of)
  return _internal_of();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metric::set_of(ArgT0&& arg0, ArgT... args) {
 
 _impl_.of_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Metric.of)
}
inline std::string* Metric::mutable_of() {
  std::string* _s = _internal_mutable_of();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Metric.of)
  return _s;
}
inline const std::string& Metric::_internal_of() const {
  return _impl_.of_.Get();
}
inline void Metric::_internal_set_of(const std::string& value) {
  
  _impl_.of_.Set(value, GetArenaForAllocation());
}
inline std::string* Metric::_internal_mutable_of() {
  
  return _impl_.of_.Mutable(GetArenaForAllocation());
}
inline std::string* Metric::release_of() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.Metric.of)
  return _impl_.of_.Release();
}
inline void Metric::set_allocated_of(std::string* of) {
  if (of != nullptr) {
    
  } else {
    
  }
  _impl_.of_.SetAllocated(of, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.of_.IsDefault()) {
    _impl_.of_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.Metric.of)
}

// string as = 3;
inline void Metric::clear_as() {
  _impl_.as_.ClearToEmpty();
}
inline const std::string& Metric::as() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Metric.as)
  return _internal_as();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metric::set_as(ArgT0&& arg0, ArgT... args) {
 
 _impl_.as_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Metric.as)
}
inline std::string* Metric::mutable_as() {
  std::string* _s = _internal_mutable_as();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Metric.as)
  return _s;
}
inline const std::string& Metric::_internal_as() const {
  return _impl_.as_.Get();
}
inline void Metric::_internal_set_as(const std::string& value) {
  
  _impl_.as_.Set(value, GetArenaForAllocation());
}
inline std::string* Metric::_internal_mutable_as() {
  
  return _impl_.as_.Mutable(GetArenaForAllocation());
}
inline std::string* Metric::release_as() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.Metric.as)
  return _impl_.as_.Release();
}
inline void Metric::set_allocated_as(std::string* as) {
  if (as != nullptr) {
    
  } else {
    
  }
  _impl_.as_.SetAllocated(as, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.as_.IsDefault()) {
    _impl_.as_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.Metric.as)
}

// string name = 4;
inline void Metric::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Metric::name() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Metric.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metric::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Metric.name)
}
inline std::string* Metric::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Metric.name)
  return _s;
}
inline const std::string& Metric::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Metric::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Metric::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Metric::release_name() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.Metric.name)
  return _impl_.name_.Release();
}
inline void Metric::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.Metric.name)
}

// -------------------------------------------------------------------

// ColumnDefinition

// .com.isima.bios.models.proto.AttributeType type = 1;
inline void ColumnDefinition::clear_type() {
  _impl_.type_ = 0;
}
inline ::com::isima::bios::models::proto::AttributeType ColumnDefinition::_internal_type() const {
  return static_cast< ::com::isima::bios::models::proto::AttributeType >(_impl_.type_);
}
inline ::com::isima::bios::models::proto::AttributeType ColumnDefinition::type() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.ColumnDefinition.type)
  return _internal_type();
}
inline void ColumnDefinition::_internal_set_type(::com::isima::bios::models::proto::AttributeType value) {
  
  _impl_.type_ = value;
}
inline void ColumnDefinition::set_type(::com::isima::bios::models::proto::AttributeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.ColumnDefinition.type)
}

// string name = 2;
inline void ColumnDefinition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ColumnDefinition::name() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.ColumnDefinition.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDefinition::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.ColumnDefinition.name)
}
inline std::string* ColumnDefinition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.ColumnDefinition.name)
  return _s;
}
inline const std::string& ColumnDefinition::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ColumnDefinition::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDefinition::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDefinition::release_name() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.ColumnDefinition.name)
  return _impl_.name_.Release();
}
inline void ColumnDefinition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.ColumnDefinition.name)
}

// int32 index_in_value_array = 3;
inline void ColumnDefinition::clear_index_in_value_array() {
  _impl_.index_in_value_array_ = 0;
}
inline int32_t ColumnDefinition::_internal_index_in_value_array() const {
  return _impl_.index_in_value_array_;
}
inline int32_t ColumnDefinition::index_in_value_array() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.ColumnDefinition.index_in_value_array)
  return _internal_index_in_value_array();
}
inline void ColumnDefinition::_internal_set_index_in_value_array(int32_t value) {
  
  _impl_.index_in_value_array_ = value;
}
inline void ColumnDefinition::set_index_in_value_array(int32_t value) {
  _internal_set_index_in_value_array(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.ColumnDefinition.index_in_value_array)
}

// -------------------------------------------------------------------

// AttributeList

// repeated string attributes = 1;
inline int AttributeList::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int AttributeList::attributes_size() const {
  return _internal_attributes_size();
}
inline void AttributeList::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline std::string* AttributeList::add_attributes() {
  std::string* _s = _internal_add_attributes();
  // @@protoc_insertion_point(field_add_mutable:com.isima.bios.models.proto.AttributeList.attributes)
  return _s;
}
inline const std::string& AttributeList::_internal_attributes(int index) const {
  return _impl_.attributes_.Get(index);
}
inline const std::string& AttributeList::attributes(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.AttributeList.attributes)
  return _internal_attributes(index);
}
inline std::string* AttributeList::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.AttributeList.attributes)
  return _impl_.attributes_.Mutable(index);
}
inline void AttributeList::set_attributes(int index, const std::string& value) {
  _impl_.attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.AttributeList.attributes)
}
inline void AttributeList::set_attributes(int index, std::string&& value) {
  _impl_.attributes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.AttributeList.attributes)
}
inline void AttributeList::set_attributes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.isima.bios.models.proto.AttributeList.attributes)
}
inline void AttributeList::set_attributes(int index, const char* value, size_t size) {
  _impl_.attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.isima.bios.models.proto.AttributeList.attributes)
}
inline std::string* AttributeList::_internal_add_attributes() {
  return _impl_.attributes_.Add();
}
inline void AttributeList::add_attributes(const std::string& value) {
  _impl_.attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.AttributeList.attributes)
}
inline void AttributeList::add_attributes(std::string&& value) {
  _impl_.attributes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.AttributeList.attributes)
}
inline void AttributeList::add_attributes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.isima.bios.models.proto.AttributeList.attributes)
}
inline void AttributeList::add_attributes(const char* value, size_t size) {
  _impl_.attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.isima.bios.models.proto.AttributeList.attributes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AttributeList::attributes() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.AttributeList.attributes)
  return _impl_.attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AttributeList::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.AttributeList.attributes)
  return &_impl_.attributes_;
}

// -------------------------------------------------------------------

// Record

// bytes event_id = 1;
inline void Record::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& Record::event_id() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Record.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.event_id)
}
inline std::string* Record::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Record.event_id)
  return _s;
}
inline const std::string& Record::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void Record::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Record::release_event_id() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.Record.event_id)
  return _impl_.event_id_.Release();
}
inline void Record::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.Record.event_id)
}

// int64 timestamp = 2;
inline void Record::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Record::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Record::timestamp() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Record.timestamp)
  return _internal_timestamp();
}
inline void Record::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Record::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.timestamp)
}

// repeated int64 long_values = 10;
inline int Record::_internal_long_values_size() const {
  return _impl_.long_values_.size();
}
inline int Record::long_values_size() const {
  return _internal_long_values_size();
}
inline void Record::clear_long_values() {
  _impl_.long_values_.Clear();
}
inline int64_t Record::_internal_long_values(int index) const {
  return _impl_.long_values_.Get(index);
}
inline int64_t Record::long_values(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Record.long_values)
  return _internal_long_values(index);
}
inline void Record::set_long_values(int index, int64_t value) {
  _impl_.long_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.long_values)
}
inline void Record::_internal_add_long_values(int64_t value) {
  _impl_.long_values_.Add(value);
}
inline void Record::add_long_values(int64_t value) {
  _internal_add_long_values(value);
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Record.long_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Record::_internal_long_values() const {
  return _impl_.long_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Record::long_values() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.Record.long_values)
  return _internal_long_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Record::_internal_mutable_long_values() {
  return &_impl_.long_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Record::mutable_long_values() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.Record.long_values)
  return _internal_mutable_long_values();
}

// repeated double double_values = 11;
inline int Record::_internal_double_values_size() const {
  return _impl_.double_values_.size();
}
inline int Record::double_values_size() const {
  return _internal_double_values_size();
}
inline void Record::clear_double_values() {
  _impl_.double_values_.Clear();
}
inline double Record::_internal_double_values(int index) const {
  return _impl_.double_values_.Get(index);
}
inline double Record::double_values(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Record.double_values)
  return _internal_double_values(index);
}
inline void Record::set_double_values(int index, double value) {
  _impl_.double_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.double_values)
}
inline void Record::_internal_add_double_values(double value) {
  _impl_.double_values_.Add(value);
}
inline void Record::add_double_values(double value) {
  _internal_add_double_values(value);
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Record.double_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Record::_internal_double_values() const {
  return _impl_.double_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Record::double_values() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.Record.double_values)
  return _internal_double_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Record::_internal_mutable_double_values() {
  return &_impl_.double_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Record::mutable_double_values() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.Record.double_values)
  return _internal_mutable_double_values();
}

// repeated string string_values = 12;
inline int Record::_internal_string_values_size() const {
  return _impl_.string_values_.size();
}
inline int Record::string_values_size() const {
  return _internal_string_values_size();
}
inline void Record::clear_string_values() {
  _impl_.string_values_.Clear();
}
inline std::string* Record::add_string_values() {
  std::string* _s = _internal_add_string_values();
  // @@protoc_insertion_point(field_add_mutable:com.isima.bios.models.proto.Record.string_values)
  return _s;
}
inline const std::string& Record::_internal_string_values(int index) const {
  return _impl_.string_values_.Get(index);
}
inline const std::string& Record::string_values(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Record.string_values)
  return _internal_string_values(index);
}
inline std::string* Record::mutable_string_values(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Record.string_values)
  return _impl_.string_values_.Mutable(index);
}
inline void Record::set_string_values(int index, const std::string& value) {
  _impl_.string_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.string_values)
}
inline void Record::set_string_values(int index, std::string&& value) {
  _impl_.string_values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.string_values)
}
inline void Record::set_string_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.string_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.isima.bios.models.proto.Record.string_values)
}
inline void Record::set_string_values(int index, const char* value, size_t size) {
  _impl_.string_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.isima.bios.models.proto.Record.string_values)
}
inline std::string* Record::_internal_add_string_values() {
  return _impl_.string_values_.Add();
}
inline void Record::add_string_values(const std::string& value) {
  _impl_.string_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Record.string_values)
}
inline void Record::add_string_values(std::string&& value) {
  _impl_.string_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Record.string_values)
}
inline void Record::add_string_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.string_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.isima.bios.models.proto.Record.string_values)
}
inline void Record::add_string_values(const char* value, size_t size) {
  _impl_.string_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.isima.bios.models.proto.Record.string_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Record::string_values() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.Record.string_values)
  return _impl_.string_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Record::mutable_string_values() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.Record.string_values)
  return &_impl_.string_values_;
}

// repeated bytes blob_values = 13;
inline int Record::_internal_blob_values_size() const {
  return _impl_.blob_values_.size();
}
inline int Record::blob_values_size() const {
  return _internal_blob_values_size();
}
inline void Record::clear_blob_values() {
  _impl_.blob_values_.Clear();
}
inline std::string* Record::add_blob_values() {
  std::string* _s = _internal_add_blob_values();
  // @@protoc_insertion_point(field_add_mutable:com.isima.bios.models.proto.Record.blob_values)
  return _s;
}
inline const std::string& Record::_internal_blob_values(int index) const {
  return _impl_.blob_values_.Get(index);
}
inline const std::string& Record::blob_values(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Record.blob_values)
  return _internal_blob_values(index);
}
inline std::string* Record::mutable_blob_values(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Record.blob_values)
  return _impl_.blob_values_.Mutable(index);
}
inline void Record::set_blob_values(int index, const std::string& value) {
  _impl_.blob_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.blob_values)
}
inline void Record::set_blob_values(int index, std::string&& value) {
  _impl_.blob_values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.blob_values)
}
inline void Record::set_blob_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.blob_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.isima.bios.models.proto.Record.blob_values)
}
inline void Record::set_blob_values(int index, const void* value, size_t size) {
  _impl_.blob_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.isima.bios.models.proto.Record.blob_values)
}
inline std::string* Record::_internal_add_blob_values() {
  return _impl_.blob_values_.Add();
}
inline void Record::add_blob_values(const std::string& value) {
  _impl_.blob_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Record.blob_values)
}
inline void Record::add_blob_values(std::string&& value) {
  _impl_.blob_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Record.blob_values)
}
inline void Record::add_blob_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.blob_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.isima.bios.models.proto.Record.blob_values)
}
inline void Record::add_blob_values(const void* value, size_t size) {
  _impl_.blob_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.isima.bios.models.proto.Record.blob_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Record::blob_values() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.Record.blob_values)
  return _impl_.blob_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Record::mutable_blob_values() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.Record.blob_values)
  return &_impl_.blob_values_;
}

// repeated bool boolean_values = 14;
inline int Record::_internal_boolean_values_size() const {
  return _impl_.boolean_values_.size();
}
inline int Record::boolean_values_size() const {
  return _internal_boolean_values_size();
}
inline void Record::clear_boolean_values() {
  _impl_.boolean_values_.Clear();
}
inline bool Record::_internal_boolean_values(int index) const {
  return _impl_.boolean_values_.Get(index);
}
inline bool Record::boolean_values(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Record.boolean_values)
  return _internal_boolean_values(index);
}
inline void Record::set_boolean_values(int index, bool value) {
  _impl_.boolean_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Record.boolean_values)
}
inline void Record::_internal_add_boolean_values(bool value) {
  _impl_.boolean_values_.Add(value);
}
inline void Record::add_boolean_values(bool value) {
  _internal_add_boolean_values(value);
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.Record.boolean_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
Record::_internal_boolean_values() const {
  return _impl_.boolean_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
Record::boolean_values() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.Record.boolean_values)
  return _internal_boolean_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
Record::_internal_mutable_boolean_values() {
  return &_impl_.boolean_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
Record::mutable_boolean_values() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.Record.boolean_values)
  return _internal_mutable_boolean_values();
}

// -------------------------------------------------------------------

// InsertRequest

// .com.isima.bios.models.proto.ContentRepresentation content_rep = 1;
inline void InsertRequest::clear_content_rep() {
  _impl_.content_rep_ = 0;
}
inline ::com::isima::bios::models::proto::ContentRepresentation InsertRequest::_internal_content_rep() const {
  return static_cast< ::com::isima::bios::models::proto::ContentRepresentation >(_impl_.content_rep_);
}
inline ::com::isima::bios::models::proto::ContentRepresentation InsertRequest::content_rep() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertRequest.content_rep)
  return _internal_content_rep();
}
inline void InsertRequest::_internal_set_content_rep(::com::isima::bios::models::proto::ContentRepresentation value) {
  
  _impl_.content_rep_ = value;
}
inline void InsertRequest::set_content_rep(::com::isima::bios::models::proto::ContentRepresentation value) {
  _internal_set_content_rep(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertRequest.content_rep)
}

// .com.isima.bios.models.proto.Record record = 2;
inline bool InsertRequest::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool InsertRequest::has_record() const {
  return _internal_has_record();
}
inline void InsertRequest::clear_record() {
  if (GetArenaForAllocation() == nullptr && _impl_.record_ != nullptr) {
    delete _impl_.record_;
  }
  _impl_.record_ = nullptr;
}
inline const ::com::isima::bios::models::proto::Record& InsertRequest::_internal_record() const {
  const ::com::isima::bios::models::proto::Record* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::isima::bios::models::proto::Record&>(
      ::com::isima::bios::models::proto::_Record_default_instance_);
}
inline const ::com::isima::bios::models::proto::Record& InsertRequest::record() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertRequest.record)
  return _internal_record();
}
inline void InsertRequest::unsafe_arena_set_allocated_record(
    ::com::isima::bios::models::proto::Record* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.isima.bios.models.proto.InsertRequest.record)
}
inline ::com::isima::bios::models::proto::Record* InsertRequest::release_record() {
  
  ::com::isima::bios::models::proto::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::isima::bios::models::proto::Record* InsertRequest::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.InsertRequest.record)
  
  ::com::isima::bios::models::proto::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::com::isima::bios::models::proto::Record* InsertRequest::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::isima::bios::models::proto::Record>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::com::isima::bios::models::proto::Record* InsertRequest::mutable_record() {
  ::com::isima::bios::models::proto::Record* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertRequest.record)
  return _msg;
}
inline void InsertRequest::set_allocated_record(::com::isima::bios::models::proto::Record* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.InsertRequest.record)
}

// int64 schema_version = 10;
inline void InsertRequest::clear_schema_version() {
  _impl_.schema_version_ = int64_t{0};
}
inline int64_t InsertRequest::_internal_schema_version() const {
  return _impl_.schema_version_;
}
inline int64_t InsertRequest::schema_version() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertRequest.schema_version)
  return _internal_schema_version();
}
inline void InsertRequest::_internal_set_schema_version(int64_t value) {
  
  _impl_.schema_version_ = value;
}
inline void InsertRequest::set_schema_version(int64_t value) {
  _internal_set_schema_version(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertRequest.schema_version)
}

// -------------------------------------------------------------------

// InsertSuccessResponse

// bytes event_id = 1;
inline void InsertSuccessResponse::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& InsertSuccessResponse::event_id() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertSuccessResponse.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertSuccessResponse::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertSuccessResponse.event_id)
}
inline std::string* InsertSuccessResponse::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertSuccessResponse.event_id)
  return _s;
}
inline const std::string& InsertSuccessResponse::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void InsertSuccessResponse::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertSuccessResponse::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertSuccessResponse::release_event_id() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.InsertSuccessResponse.event_id)
  return _impl_.event_id_.Release();
}
inline void InsertSuccessResponse::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.InsertSuccessResponse.event_id)
}

// int64 insert_timestamp = 2;
inline void InsertSuccessResponse::clear_insert_timestamp() {
  _impl_.insert_timestamp_ = int64_t{0};
}
inline int64_t InsertSuccessResponse::_internal_insert_timestamp() const {
  return _impl_.insert_timestamp_;
}
inline int64_t InsertSuccessResponse::insert_timestamp() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertSuccessResponse.insert_timestamp)
  return _internal_insert_timestamp();
}
inline void InsertSuccessResponse::_internal_set_insert_timestamp(int64_t value) {
  
  _impl_.insert_timestamp_ = value;
}
inline void InsertSuccessResponse::set_insert_timestamp(int64_t value) {
  _internal_set_insert_timestamp(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertSuccessResponse.insert_timestamp)
}

// -------------------------------------------------------------------

// InsertBulkRequest

// .com.isima.bios.models.proto.ContentRepresentation content_rep = 1;
inline void InsertBulkRequest::clear_content_rep() {
  _impl_.content_rep_ = 0;
}
inline ::com::isima::bios::models::proto::ContentRepresentation InsertBulkRequest::_internal_content_rep() const {
  return static_cast< ::com::isima::bios::models::proto::ContentRepresentation >(_impl_.content_rep_);
}
inline ::com::isima::bios::models::proto::ContentRepresentation InsertBulkRequest::content_rep() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertBulkRequest.content_rep)
  return _internal_content_rep();
}
inline void InsertBulkRequest::_internal_set_content_rep(::com::isima::bios::models::proto::ContentRepresentation value) {
  
  _impl_.content_rep_ = value;
}
inline void InsertBulkRequest::set_content_rep(::com::isima::bios::models::proto::ContentRepresentation value) {
  _internal_set_content_rep(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertBulkRequest.content_rep)
}

// repeated .com.isima.bios.models.proto.Record record = 2;
inline int InsertBulkRequest::_internal_record_size() const {
  return _impl_.record_.size();
}
inline int InsertBulkRequest::record_size() const {
  return _internal_record_size();
}
inline void InsertBulkRequest::clear_record() {
  _impl_.record_.Clear();
}
inline ::com::isima::bios::models::proto::Record* InsertBulkRequest::mutable_record(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertBulkRequest.record)
  return _impl_.record_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record >*
InsertBulkRequest::mutable_record() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.InsertBulkRequest.record)
  return &_impl_.record_;
}
inline const ::com::isima::bios::models::proto::Record& InsertBulkRequest::_internal_record(int index) const {
  return _impl_.record_.Get(index);
}
inline const ::com::isima::bios::models::proto::Record& InsertBulkRequest::record(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertBulkRequest.record)
  return _internal_record(index);
}
inline ::com::isima::bios::models::proto::Record* InsertBulkRequest::_internal_add_record() {
  return _impl_.record_.Add();
}
inline ::com::isima::bios::models::proto::Record* InsertBulkRequest::add_record() {
  ::com::isima::bios::models::proto::Record* _add = _internal_add_record();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.InsertBulkRequest.record)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record >&
InsertBulkRequest::record() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.InsertBulkRequest.record)
  return _impl_.record_;
}

// string signal = 5;
inline void InsertBulkRequest::clear_signal() {
  _impl_.signal_.ClearToEmpty();
}
inline const std::string& InsertBulkRequest::signal() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertBulkRequest.signal)
  return _internal_signal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertBulkRequest::set_signal(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signal_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertBulkRequest.signal)
}
inline std::string* InsertBulkRequest::mutable_signal() {
  std::string* _s = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertBulkRequest.signal)
  return _s;
}
inline const std::string& InsertBulkRequest::_internal_signal() const {
  return _impl_.signal_.Get();
}
inline void InsertBulkRequest::_internal_set_signal(const std::string& value) {
  
  _impl_.signal_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertBulkRequest::_internal_mutable_signal() {
  
  return _impl_.signal_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertBulkRequest::release_signal() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.InsertBulkRequest.signal)
  return _impl_.signal_.Release();
}
inline void InsertBulkRequest::set_allocated_signal(std::string* signal) {
  if (signal != nullptr) {
    
  } else {
    
  }
  _impl_.signal_.SetAllocated(signal, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signal_.IsDefault()) {
    _impl_.signal_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.InsertBulkRequest.signal)
}

// int64 schema_version = 10;
inline void InsertBulkRequest::clear_schema_version() {
  _impl_.schema_version_ = int64_t{0};
}
inline int64_t InsertBulkRequest::_internal_schema_version() const {
  return _impl_.schema_version_;
}
inline int64_t InsertBulkRequest::schema_version() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertBulkRequest.schema_version)
  return _internal_schema_version();
}
inline void InsertBulkRequest::_internal_set_schema_version(int64_t value) {
  
  _impl_.schema_version_ = value;
}
inline void InsertBulkRequest::set_schema_version(int64_t value) {
  _internal_set_schema_version(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertBulkRequest.schema_version)
}

// -------------------------------------------------------------------

// InsertBulkSuccessResponse

// repeated .com.isima.bios.models.proto.InsertSuccessResponse responses = 1;
inline int InsertBulkSuccessResponse::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int InsertBulkSuccessResponse::responses_size() const {
  return _internal_responses_size();
}
inline void InsertBulkSuccessResponse::clear_responses() {
  _impl_.responses_.Clear();
}
inline ::com::isima::bios::models::proto::InsertSuccessResponse* InsertBulkSuccessResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertBulkSuccessResponse.responses)
  return _impl_.responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessResponse >*
InsertBulkSuccessResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.InsertBulkSuccessResponse.responses)
  return &_impl_.responses_;
}
inline const ::com::isima::bios::models::proto::InsertSuccessResponse& InsertBulkSuccessResponse::_internal_responses(int index) const {
  return _impl_.responses_.Get(index);
}
inline const ::com::isima::bios::models::proto::InsertSuccessResponse& InsertBulkSuccessResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertBulkSuccessResponse.responses)
  return _internal_responses(index);
}
inline ::com::isima::bios::models::proto::InsertSuccessResponse* InsertBulkSuccessResponse::_internal_add_responses() {
  return _impl_.responses_.Add();
}
inline ::com::isima::bios::models::proto::InsertSuccessResponse* InsertBulkSuccessResponse::add_responses() {
  ::com::isima::bios::models::proto::InsertSuccessResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.InsertBulkSuccessResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessResponse >&
InsertBulkSuccessResponse::responses() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.InsertBulkSuccessResponse.responses)
  return _impl_.responses_;
}

// -------------------------------------------------------------------

// InsertSuccessOrError

// string event_id = 1;
inline void InsertSuccessOrError::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& InsertSuccessOrError::event_id() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertSuccessOrError.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertSuccessOrError::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertSuccessOrError.event_id)
}
inline std::string* InsertSuccessOrError::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertSuccessOrError.event_id)
  return _s;
}
inline const std::string& InsertSuccessOrError::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void InsertSuccessOrError::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertSuccessOrError::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertSuccessOrError::release_event_id() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.InsertSuccessOrError.event_id)
  return _impl_.event_id_.Release();
}
inline void InsertSuccessOrError::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.InsertSuccessOrError.event_id)
}

// int64 insert_timestamp = 2;
inline void InsertSuccessOrError::clear_insert_timestamp() {
  _impl_.insert_timestamp_ = int64_t{0};
}
inline int64_t InsertSuccessOrError::_internal_insert_timestamp() const {
  return _impl_.insert_timestamp_;
}
inline int64_t InsertSuccessOrError::insert_timestamp() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertSuccessOrError.insert_timestamp)
  return _internal_insert_timestamp();
}
inline void InsertSuccessOrError::_internal_set_insert_timestamp(int64_t value) {
  
  _impl_.insert_timestamp_ = value;
}
inline void InsertSuccessOrError::set_insert_timestamp(int64_t value) {
  _internal_set_insert_timestamp(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertSuccessOrError.insert_timestamp)
}

// string error_message = 10;
inline void InsertSuccessOrError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& InsertSuccessOrError::error_message() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertSuccessOrError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertSuccessOrError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertSuccessOrError.error_message)
}
inline std::string* InsertSuccessOrError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertSuccessOrError.error_message)
  return _s;
}
inline const std::string& InsertSuccessOrError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void InsertSuccessOrError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertSuccessOrError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertSuccessOrError::release_error_message() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.InsertSuccessOrError.error_message)
  return _impl_.error_message_.Release();
}
inline void InsertSuccessOrError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.InsertSuccessOrError.error_message)
}

// string server_error_code = 11;
inline void InsertSuccessOrError::clear_server_error_code() {
  _impl_.server_error_code_.ClearToEmpty();
}
inline const std::string& InsertSuccessOrError::server_error_code() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertSuccessOrError.server_error_code)
  return _internal_server_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertSuccessOrError::set_server_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertSuccessOrError.server_error_code)
}
inline std::string* InsertSuccessOrError::mutable_server_error_code() {
  std::string* _s = _internal_mutable_server_error_code();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertSuccessOrError.server_error_code)
  return _s;
}
inline const std::string& InsertSuccessOrError::_internal_server_error_code() const {
  return _impl_.server_error_code_.Get();
}
inline void InsertSuccessOrError::_internal_set_server_error_code(const std::string& value) {
  
  _impl_.server_error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertSuccessOrError::_internal_mutable_server_error_code() {
  
  return _impl_.server_error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertSuccessOrError::release_server_error_code() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.InsertSuccessOrError.server_error_code)
  return _impl_.server_error_code_.Release();
}
inline void InsertSuccessOrError::set_allocated_server_error_code(std::string* server_error_code) {
  if (server_error_code != nullptr) {
    
  } else {
    
  }
  _impl_.server_error_code_.SetAllocated(server_error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_error_code_.IsDefault()) {
    _impl_.server_error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.InsertSuccessOrError.server_error_code)
}

// -------------------------------------------------------------------

// InsertBulkErrorResponse

// string server_error_code = 1;
inline void InsertBulkErrorResponse::clear_server_error_code() {
  _impl_.server_error_code_.ClearToEmpty();
}
inline const std::string& InsertBulkErrorResponse::server_error_code() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_code)
  return _internal_server_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertBulkErrorResponse::set_server_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_code)
}
inline std::string* InsertBulkErrorResponse::mutable_server_error_code() {
  std::string* _s = _internal_mutable_server_error_code();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_code)
  return _s;
}
inline const std::string& InsertBulkErrorResponse::_internal_server_error_code() const {
  return _impl_.server_error_code_.Get();
}
inline void InsertBulkErrorResponse::_internal_set_server_error_code(const std::string& value) {
  
  _impl_.server_error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertBulkErrorResponse::_internal_mutable_server_error_code() {
  
  return _impl_.server_error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertBulkErrorResponse::release_server_error_code() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_code)
  return _impl_.server_error_code_.Release();
}
inline void InsertBulkErrorResponse::set_allocated_server_error_code(std::string* server_error_code) {
  if (server_error_code != nullptr) {
    
  } else {
    
  }
  _impl_.server_error_code_.SetAllocated(server_error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_error_code_.IsDefault()) {
    _impl_.server_error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_code)
}

// string server_error_message = 2;
inline void InsertBulkErrorResponse::clear_server_error_message() {
  _impl_.server_error_message_.ClearToEmpty();
}
inline const std::string& InsertBulkErrorResponse::server_error_message() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_message)
  return _internal_server_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertBulkErrorResponse::set_server_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_message)
}
inline std::string* InsertBulkErrorResponse::mutable_server_error_message() {
  std::string* _s = _internal_mutable_server_error_message();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_message)
  return _s;
}
inline const std::string& InsertBulkErrorResponse::_internal_server_error_message() const {
  return _impl_.server_error_message_.Get();
}
inline void InsertBulkErrorResponse::_internal_set_server_error_message(const std::string& value) {
  
  _impl_.server_error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertBulkErrorResponse::_internal_mutable_server_error_message() {
  
  return _impl_.server_error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertBulkErrorResponse::release_server_error_message() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_message)
  return _impl_.server_error_message_.Release();
}
inline void InsertBulkErrorResponse::set_allocated_server_error_message(std::string* server_error_message) {
  if (server_error_message != nullptr) {
    
  } else {
    
  }
  _impl_.server_error_message_.SetAllocated(server_error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_error_message_.IsDefault()) {
    _impl_.server_error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.InsertBulkErrorResponse.server_error_message)
}

// repeated .com.isima.bios.models.proto.InsertSuccessOrError results_with_error = 4;
inline int InsertBulkErrorResponse::_internal_results_with_error_size() const {
  return _impl_.results_with_error_.size();
}
inline int InsertBulkErrorResponse::results_with_error_size() const {
  return _internal_results_with_error_size();
}
inline void InsertBulkErrorResponse::clear_results_with_error() {
  _impl_.results_with_error_.Clear();
}
inline ::com::isima::bios::models::proto::InsertSuccessOrError* InsertBulkErrorResponse::mutable_results_with_error(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.InsertBulkErrorResponse.results_with_error)
  return _impl_.results_with_error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessOrError >*
InsertBulkErrorResponse::mutable_results_with_error() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.InsertBulkErrorResponse.results_with_error)
  return &_impl_.results_with_error_;
}
inline const ::com::isima::bios::models::proto::InsertSuccessOrError& InsertBulkErrorResponse::_internal_results_with_error(int index) const {
  return _impl_.results_with_error_.Get(index);
}
inline const ::com::isima::bios::models::proto::InsertSuccessOrError& InsertBulkErrorResponse::results_with_error(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.InsertBulkErrorResponse.results_with_error)
  return _internal_results_with_error(index);
}
inline ::com::isima::bios::models::proto::InsertSuccessOrError* InsertBulkErrorResponse::_internal_add_results_with_error() {
  return _impl_.results_with_error_.Add();
}
inline ::com::isima::bios::models::proto::InsertSuccessOrError* InsertBulkErrorResponse::add_results_with_error() {
  ::com::isima::bios::models::proto::InsertSuccessOrError* _add = _internal_add_results_with_error();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.InsertBulkErrorResponse.results_with_error)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::InsertSuccessOrError >&
InsertBulkErrorResponse::results_with_error() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.InsertBulkErrorResponse.results_with_error)
  return _impl_.results_with_error_;
}

// -------------------------------------------------------------------

// SlidingWindow

// int64 slide_interval = 1;
inline void SlidingWindow::clear_slide_interval() {
  _impl_.slide_interval_ = int64_t{0};
}
inline int64_t SlidingWindow::_internal_slide_interval() const {
  return _impl_.slide_interval_;
}
inline int64_t SlidingWindow::slide_interval() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SlidingWindow.slide_interval)
  return _internal_slide_interval();
}
inline void SlidingWindow::_internal_set_slide_interval(int64_t value) {
  
  _impl_.slide_interval_ = value;
}
inline void SlidingWindow::set_slide_interval(int64_t value) {
  _internal_set_slide_interval(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SlidingWindow.slide_interval)
}

// int32 window_slides = 2;
inline void SlidingWindow::clear_window_slides() {
  _impl_.window_slides_ = 0;
}
inline int32_t SlidingWindow::_internal_window_slides() const {
  return _impl_.window_slides_;
}
inline int32_t SlidingWindow::window_slides() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SlidingWindow.window_slides)
  return _internal_window_slides();
}
inline void SlidingWindow::_internal_set_window_slides(int32_t value) {
  
  _impl_.window_slides_ = value;
}
inline void SlidingWindow::set_window_slides(int32_t value) {
  _internal_set_window_slides(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SlidingWindow.window_slides)
}

// -------------------------------------------------------------------

// TumblingWindow

// int64 window_size_ms = 1;
inline void TumblingWindow::clear_window_size_ms() {
  _impl_.window_size_ms_ = int64_t{0};
}
inline int64_t TumblingWindow::_internal_window_size_ms() const {
  return _impl_.window_size_ms_;
}
inline int64_t TumblingWindow::window_size_ms() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.TumblingWindow.window_size_ms)
  return _internal_window_size_ms();
}
inline void TumblingWindow::_internal_set_window_size_ms(int64_t value) {
  
  _impl_.window_size_ms_ = value;
}
inline void TumblingWindow::set_window_size_ms(int64_t value) {
  _internal_set_window_size_ms(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.TumblingWindow.window_size_ms)
}

// -------------------------------------------------------------------

// Window

// .com.isima.bios.models.proto.WindowType window_type = 1;
inline void Window::clear_window_type() {
  _impl_.window_type_ = 0;
}
inline ::com::isima::bios::models::proto::WindowType Window::_internal_window_type() const {
  return static_cast< ::com::isima::bios::models::proto::WindowType >(_impl_.window_type_);
}
inline ::com::isima::bios::models::proto::WindowType Window::window_type() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Window.window_type)
  return _internal_window_type();
}
inline void Window::_internal_set_window_type(::com::isima::bios::models::proto::WindowType value) {
  
  _impl_.window_type_ = value;
}
inline void Window::set_window_type(::com::isima::bios::models::proto::WindowType value) {
  _internal_set_window_type(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.Window.window_type)
}

// .com.isima.bios.models.proto.SlidingWindow sliding = 10;
inline bool Window::_internal_has_sliding() const {
  return window_details_case() == kSliding;
}
inline bool Window::has_sliding() const {
  return _internal_has_sliding();
}
inline void Window::set_has_sliding() {
  _impl_._oneof_case_[0] = kSliding;
}
inline void Window::clear_sliding() {
  if (_internal_has_sliding()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.window_details_.sliding_;
    }
    clear_has_window_details();
  }
}
inline ::com::isima::bios::models::proto::SlidingWindow* Window::release_sliding() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.Window.sliding)
  if (_internal_has_sliding()) {
    clear_has_window_details();
    ::com::isima::bios::models::proto::SlidingWindow* temp = _impl_.window_details_.sliding_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.window_details_.sliding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::isima::bios::models::proto::SlidingWindow& Window::_internal_sliding() const {
  return _internal_has_sliding()
      ? *_impl_.window_details_.sliding_
      : reinterpret_cast< ::com::isima::bios::models::proto::SlidingWindow&>(::com::isima::bios::models::proto::_SlidingWindow_default_instance_);
}
inline const ::com::isima::bios::models::proto::SlidingWindow& Window::sliding() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Window.sliding)
  return _internal_sliding();
}
inline ::com::isima::bios::models::proto::SlidingWindow* Window::unsafe_arena_release_sliding() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.isima.bios.models.proto.Window.sliding)
  if (_internal_has_sliding()) {
    clear_has_window_details();
    ::com::isima::bios::models::proto::SlidingWindow* temp = _impl_.window_details_.sliding_;
    _impl_.window_details_.sliding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Window::unsafe_arena_set_allocated_sliding(::com::isima::bios::models::proto::SlidingWindow* sliding) {
  clear_window_details();
  if (sliding) {
    set_has_sliding();
    _impl_.window_details_.sliding_ = sliding;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.isima.bios.models.proto.Window.sliding)
}
inline ::com::isima::bios::models::proto::SlidingWindow* Window::_internal_mutable_sliding() {
  if (!_internal_has_sliding()) {
    clear_window_details();
    set_has_sliding();
    _impl_.window_details_.sliding_ = CreateMaybeMessage< ::com::isima::bios::models::proto::SlidingWindow >(GetArenaForAllocation());
  }
  return _impl_.window_details_.sliding_;
}
inline ::com::isima::bios::models::proto::SlidingWindow* Window::mutable_sliding() {
  ::com::isima::bios::models::proto::SlidingWindow* _msg = _internal_mutable_sliding();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Window.sliding)
  return _msg;
}

// .com.isima.bios.models.proto.TumblingWindow tumbling = 11;
inline bool Window::_internal_has_tumbling() const {
  return window_details_case() == kTumbling;
}
inline bool Window::has_tumbling() const {
  return _internal_has_tumbling();
}
inline void Window::set_has_tumbling() {
  _impl_._oneof_case_[0] = kTumbling;
}
inline void Window::clear_tumbling() {
  if (_internal_has_tumbling()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.window_details_.tumbling_;
    }
    clear_has_window_details();
  }
}
inline ::com::isima::bios::models::proto::TumblingWindow* Window::release_tumbling() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.Window.tumbling)
  if (_internal_has_tumbling()) {
    clear_has_window_details();
    ::com::isima::bios::models::proto::TumblingWindow* temp = _impl_.window_details_.tumbling_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.window_details_.tumbling_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::isima::bios::models::proto::TumblingWindow& Window::_internal_tumbling() const {
  return _internal_has_tumbling()
      ? *_impl_.window_details_.tumbling_
      : reinterpret_cast< ::com::isima::bios::models::proto::TumblingWindow&>(::com::isima::bios::models::proto::_TumblingWindow_default_instance_);
}
inline const ::com::isima::bios::models::proto::TumblingWindow& Window::tumbling() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.Window.tumbling)
  return _internal_tumbling();
}
inline ::com::isima::bios::models::proto::TumblingWindow* Window::unsafe_arena_release_tumbling() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.isima.bios.models.proto.Window.tumbling)
  if (_internal_has_tumbling()) {
    clear_has_window_details();
    ::com::isima::bios::models::proto::TumblingWindow* temp = _impl_.window_details_.tumbling_;
    _impl_.window_details_.tumbling_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Window::unsafe_arena_set_allocated_tumbling(::com::isima::bios::models::proto::TumblingWindow* tumbling) {
  clear_window_details();
  if (tumbling) {
    set_has_tumbling();
    _impl_.window_details_.tumbling_ = tumbling;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.isima.bios.models.proto.Window.tumbling)
}
inline ::com::isima::bios::models::proto::TumblingWindow* Window::_internal_mutable_tumbling() {
  if (!_internal_has_tumbling()) {
    clear_window_details();
    set_has_tumbling();
    _impl_.window_details_.tumbling_ = CreateMaybeMessage< ::com::isima::bios::models::proto::TumblingWindow >(GetArenaForAllocation());
  }
  return _impl_.window_details_.tumbling_;
}
inline ::com::isima::bios::models::proto::TumblingWindow* Window::mutable_tumbling() {
  ::com::isima::bios::models::proto::TumblingWindow* _msg = _internal_mutable_tumbling();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.Window.tumbling)
  return _msg;
}

inline bool Window::has_window_details() const {
  return window_details_case() != WINDOW_DETAILS_NOT_SET;
}
inline void Window::clear_has_window_details() {
  _impl_._oneof_case_[0] = WINDOW_DETAILS_NOT_SET;
}
inline Window::WindowDetailsCase Window::window_details_case() const {
  return Window::WindowDetailsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SelectQuery

// int64 start_time = 1;
inline void SelectQuery::clear_start_time() {
  _impl_.start_time_ = int64_t{0};
}
inline int64_t SelectQuery::_internal_start_time() const {
  return _impl_.start_time_;
}
inline int64_t SelectQuery::start_time() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.start_time)
  return _internal_start_time();
}
inline void SelectQuery::_internal_set_start_time(int64_t value) {
  
  _impl_.start_time_ = value;
}
inline void SelectQuery::set_start_time(int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQuery.start_time)
}

// int64 end_time = 2;
inline void SelectQuery::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t SelectQuery::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t SelectQuery::end_time() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.end_time)
  return _internal_end_time();
}
inline void SelectQuery::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void SelectQuery::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQuery.end_time)
}

// bool distinct = 10;
inline void SelectQuery::clear_distinct() {
  _impl_.distinct_ = false;
}
inline bool SelectQuery::_internal_distinct() const {
  return _impl_.distinct_;
}
inline bool SelectQuery::distinct() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.distinct)
  return _internal_distinct();
}
inline void SelectQuery::_internal_set_distinct(bool value) {
  
  _impl_.distinct_ = value;
}
inline void SelectQuery::set_distinct(bool value) {
  _internal_set_distinct(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQuery.distinct)
}

// .com.isima.bios.models.proto.AttributeList attributes = 11;
inline bool SelectQuery::_internal_has_attributes() const {
  return this != internal_default_instance() && _impl_.attributes_ != nullptr;
}
inline bool SelectQuery::has_attributes() const {
  return _internal_has_attributes();
}
inline void SelectQuery::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.attributes_ != nullptr) {
    delete _impl_.attributes_;
  }
  _impl_.attributes_ = nullptr;
}
inline const ::com::isima::bios::models::proto::AttributeList& SelectQuery::_internal_attributes() const {
  const ::com::isima::bios::models::proto::AttributeList* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::isima::bios::models::proto::AttributeList&>(
      ::com::isima::bios::models::proto::_AttributeList_default_instance_);
}
inline const ::com::isima::bios::models::proto::AttributeList& SelectQuery::attributes() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.attributes)
  return _internal_attributes();
}
inline void SelectQuery::unsafe_arena_set_allocated_attributes(
    ::com::isima::bios::models::proto::AttributeList* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.isima.bios.models.proto.SelectQuery.attributes)
}
inline ::com::isima::bios::models::proto::AttributeList* SelectQuery::release_attributes() {
  
  ::com::isima::bios::models::proto::AttributeList* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::isima::bios::models::proto::AttributeList* SelectQuery::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.SelectQuery.attributes)
  
  ::com::isima::bios::models::proto::AttributeList* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::com::isima::bios::models::proto::AttributeList* SelectQuery::_internal_mutable_attributes() {
  
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::isima::bios::models::proto::AttributeList>(GetArenaForAllocation());
    _impl_.attributes_ = p;
  }
  return _impl_.attributes_;
}
inline ::com::isima::bios::models::proto::AttributeList* SelectQuery::mutable_attributes() {
  ::com::isima::bios::models::proto::AttributeList* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQuery.attributes)
  return _msg;
}
inline void SelectQuery::set_allocated_attributes(::com::isima::bios::models::proto::AttributeList* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.SelectQuery.attributes)
}

// repeated .com.isima.bios.models.proto.Metric metrics = 12;
inline int SelectQuery::_internal_metrics_size() const {
  return _impl_.metrics_.size();
}
inline int SelectQuery::metrics_size() const {
  return _internal_metrics_size();
}
inline void SelectQuery::clear_metrics() {
  _impl_.metrics_.Clear();
}
inline ::com::isima::bios::models::proto::Metric* SelectQuery::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQuery.metrics)
  return _impl_.metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Metric >*
SelectQuery::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.SelectQuery.metrics)
  return &_impl_.metrics_;
}
inline const ::com::isima::bios::models::proto::Metric& SelectQuery::_internal_metrics(int index) const {
  return _impl_.metrics_.Get(index);
}
inline const ::com::isima::bios::models::proto::Metric& SelectQuery::metrics(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.metrics)
  return _internal_metrics(index);
}
inline ::com::isima::bios::models::proto::Metric* SelectQuery::_internal_add_metrics() {
  return _impl_.metrics_.Add();
}
inline ::com::isima::bios::models::proto::Metric* SelectQuery::add_metrics() {
  ::com::isima::bios::models::proto::Metric* _add = _internal_add_metrics();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.SelectQuery.metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Metric >&
SelectQuery::metrics() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.SelectQuery.metrics)
  return _impl_.metrics_;
}

// string from = 15;
inline void SelectQuery::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& SelectQuery::from() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectQuery::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQuery.from)
}
inline std::string* SelectQuery::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQuery.from)
  return _s;
}
inline const std::string& SelectQuery::_internal_from() const {
  return _impl_.from_.Get();
}
inline void SelectQuery::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectQuery::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectQuery::release_from() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.SelectQuery.from)
  return _impl_.from_.Release();
}
inline void SelectQuery::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.SelectQuery.from)
}

// string where = 20;
inline void SelectQuery::clear_where() {
  _impl_.where_.ClearToEmpty();
}
inline const std::string& SelectQuery::where() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.where)
  return _internal_where();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectQuery::set_where(ArgT0&& arg0, ArgT... args) {
 
 _impl_.where_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQuery.where)
}
inline std::string* SelectQuery::mutable_where() {
  std::string* _s = _internal_mutable_where();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQuery.where)
  return _s;
}
inline const std::string& SelectQuery::_internal_where() const {
  return _impl_.where_.Get();
}
inline void SelectQuery::_internal_set_where(const std::string& value) {
  
  _impl_.where_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectQuery::_internal_mutable_where() {
  
  return _impl_.where_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectQuery::release_where() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.SelectQuery.where)
  return _impl_.where_.Release();
}
inline void SelectQuery::set_allocated_where(std::string* where) {
  if (where != nullptr) {
    
  } else {
    
  }
  _impl_.where_.SetAllocated(where, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.where_.IsDefault()) {
    _impl_.where_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.SelectQuery.where)
}

// .com.isima.bios.models.proto.Dimensions group_by = 30;
inline bool SelectQuery::_internal_has_group_by() const {
  return this != internal_default_instance() && _impl_.group_by_ != nullptr;
}
inline bool SelectQuery::has_group_by() const {
  return _internal_has_group_by();
}
inline void SelectQuery::clear_group_by() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_by_ != nullptr) {
    delete _impl_.group_by_;
  }
  _impl_.group_by_ = nullptr;
}
inline const ::com::isima::bios::models::proto::Dimensions& SelectQuery::_internal_group_by() const {
  const ::com::isima::bios::models::proto::Dimensions* p = _impl_.group_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::isima::bios::models::proto::Dimensions&>(
      ::com::isima::bios::models::proto::_Dimensions_default_instance_);
}
inline const ::com::isima::bios::models::proto::Dimensions& SelectQuery::group_by() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.group_by)
  return _internal_group_by();
}
inline void SelectQuery::unsafe_arena_set_allocated_group_by(
    ::com::isima::bios::models::proto::Dimensions* group_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_by_);
  }
  _impl_.group_by_ = group_by;
  if (group_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.isima.bios.models.proto.SelectQuery.group_by)
}
inline ::com::isima::bios::models::proto::Dimensions* SelectQuery::release_group_by() {
  
  ::com::isima::bios::models::proto::Dimensions* temp = _impl_.group_by_;
  _impl_.group_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::isima::bios::models::proto::Dimensions* SelectQuery::unsafe_arena_release_group_by() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.SelectQuery.group_by)
  
  ::com::isima::bios::models::proto::Dimensions* temp = _impl_.group_by_;
  _impl_.group_by_ = nullptr;
  return temp;
}
inline ::com::isima::bios::models::proto::Dimensions* SelectQuery::_internal_mutable_group_by() {
  
  if (_impl_.group_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::isima::bios::models::proto::Dimensions>(GetArenaForAllocation());
    _impl_.group_by_ = p;
  }
  return _impl_.group_by_;
}
inline ::com::isima::bios::models::proto::Dimensions* SelectQuery::mutable_group_by() {
  ::com::isima::bios::models::proto::Dimensions* _msg = _internal_mutable_group_by();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQuery.group_by)
  return _msg;
}
inline void SelectQuery::set_allocated_group_by(::com::isima::bios::models::proto::Dimensions* group_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_by_;
  }
  if (group_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_by);
    if (message_arena != submessage_arena) {
      group_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_by, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_by_ = group_by;
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.SelectQuery.group_by)
}

// repeated .com.isima.bios.models.proto.Window windows = 40;
inline int SelectQuery::_internal_windows_size() const {
  return _impl_.windows_.size();
}
inline int SelectQuery::windows_size() const {
  return _internal_windows_size();
}
inline void SelectQuery::clear_windows() {
  _impl_.windows_.Clear();
}
inline ::com::isima::bios::models::proto::Window* SelectQuery::mutable_windows(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQuery.windows)
  return _impl_.windows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Window >*
SelectQuery::mutable_windows() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.SelectQuery.windows)
  return &_impl_.windows_;
}
inline const ::com::isima::bios::models::proto::Window& SelectQuery::_internal_windows(int index) const {
  return _impl_.windows_.Get(index);
}
inline const ::com::isima::bios::models::proto::Window& SelectQuery::windows(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.windows)
  return _internal_windows(index);
}
inline ::com::isima::bios::models::proto::Window* SelectQuery::_internal_add_windows() {
  return _impl_.windows_.Add();
}
inline ::com::isima::bios::models::proto::Window* SelectQuery::add_windows() {
  ::com::isima::bios::models::proto::Window* _add = _internal_add_windows();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.SelectQuery.windows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Window >&
SelectQuery::windows() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.SelectQuery.windows)
  return _impl_.windows_;
}

// .com.isima.bios.models.proto.OrderBy order_by = 50;
inline bool SelectQuery::_internal_has_order_by() const {
  return this != internal_default_instance() && _impl_.order_by_ != nullptr;
}
inline bool SelectQuery::has_order_by() const {
  return _internal_has_order_by();
}
inline void SelectQuery::clear_order_by() {
  if (GetArenaForAllocation() == nullptr && _impl_.order_by_ != nullptr) {
    delete _impl_.order_by_;
  }
  _impl_.order_by_ = nullptr;
}
inline const ::com::isima::bios::models::proto::OrderBy& SelectQuery::_internal_order_by() const {
  const ::com::isima::bios::models::proto::OrderBy* p = _impl_.order_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::isima::bios::models::proto::OrderBy&>(
      ::com::isima::bios::models::proto::_OrderBy_default_instance_);
}
inline const ::com::isima::bios::models::proto::OrderBy& SelectQuery::order_by() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.order_by)
  return _internal_order_by();
}
inline void SelectQuery::unsafe_arena_set_allocated_order_by(
    ::com::isima::bios::models::proto::OrderBy* order_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_by_);
  }
  _impl_.order_by_ = order_by;
  if (order_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.isima.bios.models.proto.SelectQuery.order_by)
}
inline ::com::isima::bios::models::proto::OrderBy* SelectQuery::release_order_by() {
  
  ::com::isima::bios::models::proto::OrderBy* temp = _impl_.order_by_;
  _impl_.order_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::isima::bios::models::proto::OrderBy* SelectQuery::unsafe_arena_release_order_by() {
  // @@protoc_insertion_point(field_release:com.isima.bios.models.proto.SelectQuery.order_by)
  
  ::com::isima::bios::models::proto::OrderBy* temp = _impl_.order_by_;
  _impl_.order_by_ = nullptr;
  return temp;
}
inline ::com::isima::bios::models::proto::OrderBy* SelectQuery::_internal_mutable_order_by() {
  
  if (_impl_.order_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::isima::bios::models::proto::OrderBy>(GetArenaForAllocation());
    _impl_.order_by_ = p;
  }
  return _impl_.order_by_;
}
inline ::com::isima::bios::models::proto::OrderBy* SelectQuery::mutable_order_by() {
  ::com::isima::bios::models::proto::OrderBy* _msg = _internal_mutable_order_by();
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQuery.order_by)
  return _msg;
}
inline void SelectQuery::set_allocated_order_by(::com::isima::bios::models::proto::OrderBy* order_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_by_;
  }
  if (order_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_by);
    if (message_arena != submessage_arena) {
      order_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_by, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.order_by_ = order_by;
  // @@protoc_insertion_point(field_set_allocated:com.isima.bios.models.proto.SelectQuery.order_by)
}

// optional int32 limit = 60;
inline bool SelectQuery::_internal_has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectQuery::has_limit() const {
  return _internal_has_limit();
}
inline void SelectQuery::clear_limit() {
  _impl_.limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t SelectQuery::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t SelectQuery::limit() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.limit)
  return _internal_limit();
}
inline void SelectQuery::_internal_set_limit(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.limit_ = value;
}
inline void SelectQuery::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQuery.limit)
}

// bool on_the_fly = 70;
inline void SelectQuery::clear_on_the_fly() {
  _impl_.on_the_fly_ = false;
}
inline bool SelectQuery::_internal_on_the_fly() const {
  return _impl_.on_the_fly_;
}
inline bool SelectQuery::on_the_fly() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQuery.on_the_fly)
  return _internal_on_the_fly();
}
inline void SelectQuery::_internal_set_on_the_fly(bool value) {
  
  _impl_.on_the_fly_ = value;
}
inline void SelectQuery::set_on_the_fly(bool value) {
  _internal_set_on_the_fly(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQuery.on_the_fly)
}

// -------------------------------------------------------------------

// SelectRequest

// repeated .com.isima.bios.models.proto.SelectQuery queries = 1;
inline int SelectRequest::_internal_queries_size() const {
  return _impl_.queries_.size();
}
inline int SelectRequest::queries_size() const {
  return _internal_queries_size();
}
inline void SelectRequest::clear_queries() {
  _impl_.queries_.Clear();
}
inline ::com::isima::bios::models::proto::SelectQuery* SelectRequest::mutable_queries(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectRequest.queries)
  return _impl_.queries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQuery >*
SelectRequest::mutable_queries() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.SelectRequest.queries)
  return &_impl_.queries_;
}
inline const ::com::isima::bios::models::proto::SelectQuery& SelectRequest::_internal_queries(int index) const {
  return _impl_.queries_.Get(index);
}
inline const ::com::isima::bios::models::proto::SelectQuery& SelectRequest::queries(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectRequest.queries)
  return _internal_queries(index);
}
inline ::com::isima::bios::models::proto::SelectQuery* SelectRequest::_internal_add_queries() {
  return _impl_.queries_.Add();
}
inline ::com::isima::bios::models::proto::SelectQuery* SelectRequest::add_queries() {
  ::com::isima::bios::models::proto::SelectQuery* _add = _internal_add_queries();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.SelectRequest.queries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQuery >&
SelectRequest::queries() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.SelectRequest.queries)
  return _impl_.queries_;
}

// -------------------------------------------------------------------

// QueryResult

// int64 window_begin_time = 1;
inline void QueryResult::clear_window_begin_time() {
  _impl_.window_begin_time_ = int64_t{0};
}
inline int64_t QueryResult::_internal_window_begin_time() const {
  return _impl_.window_begin_time_;
}
inline int64_t QueryResult::window_begin_time() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.QueryResult.window_begin_time)
  return _internal_window_begin_time();
}
inline void QueryResult::_internal_set_window_begin_time(int64_t value) {
  
  _impl_.window_begin_time_ = value;
}
inline void QueryResult::set_window_begin_time(int64_t value) {
  _internal_set_window_begin_time(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.QueryResult.window_begin_time)
}

// repeated .com.isima.bios.models.proto.Record records = 10;
inline int QueryResult::_internal_records_size() const {
  return _impl_.records_.size();
}
inline int QueryResult::records_size() const {
  return _internal_records_size();
}
inline void QueryResult::clear_records() {
  _impl_.records_.Clear();
}
inline ::com::isima::bios::models::proto::Record* QueryResult::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.QueryResult.records)
  return _impl_.records_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record >*
QueryResult::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.QueryResult.records)
  return &_impl_.records_;
}
inline const ::com::isima::bios::models::proto::Record& QueryResult::_internal_records(int index) const {
  return _impl_.records_.Get(index);
}
inline const ::com::isima::bios::models::proto::Record& QueryResult::records(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.QueryResult.records)
  return _internal_records(index);
}
inline ::com::isima::bios::models::proto::Record* QueryResult::_internal_add_records() {
  return _impl_.records_.Add();
}
inline ::com::isima::bios::models::proto::Record* QueryResult::add_records() {
  ::com::isima::bios::models::proto::Record* _add = _internal_add_records();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.QueryResult.records)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::Record >&
QueryResult::records() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.QueryResult.records)
  return _impl_.records_;
}

// -------------------------------------------------------------------

// SelectQueryResponse

// repeated .com.isima.bios.models.proto.QueryResult data = 1;
inline int SelectQueryResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int SelectQueryResponse::data_size() const {
  return _internal_data_size();
}
inline void SelectQueryResponse::clear_data() {
  _impl_.data_.Clear();
}
inline ::com::isima::bios::models::proto::QueryResult* SelectQueryResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQueryResponse.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::QueryResult >*
SelectQueryResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.SelectQueryResponse.data)
  return &_impl_.data_;
}
inline const ::com::isima::bios::models::proto::QueryResult& SelectQueryResponse::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::com::isima::bios::models::proto::QueryResult& SelectQueryResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQueryResponse.data)
  return _internal_data(index);
}
inline ::com::isima::bios::models::proto::QueryResult* SelectQueryResponse::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::com::isima::bios::models::proto::QueryResult* SelectQueryResponse::add_data() {
  ::com::isima::bios::models::proto::QueryResult* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.SelectQueryResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::QueryResult >&
SelectQueryResponse::data() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.SelectQueryResponse.data)
  return _impl_.data_;
}

// repeated .com.isima.bios.models.proto.ColumnDefinition definitions = 2;
inline int SelectQueryResponse::_internal_definitions_size() const {
  return _impl_.definitions_.size();
}
inline int SelectQueryResponse::definitions_size() const {
  return _internal_definitions_size();
}
inline void SelectQueryResponse::clear_definitions() {
  _impl_.definitions_.Clear();
}
inline ::com::isima::bios::models::proto::ColumnDefinition* SelectQueryResponse::mutable_definitions(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectQueryResponse.definitions)
  return _impl_.definitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::ColumnDefinition >*
SelectQueryResponse::mutable_definitions() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.SelectQueryResponse.definitions)
  return &_impl_.definitions_;
}
inline const ::com::isima::bios::models::proto::ColumnDefinition& SelectQueryResponse::_internal_definitions(int index) const {
  return _impl_.definitions_.Get(index);
}
inline const ::com::isima::bios::models::proto::ColumnDefinition& SelectQueryResponse::definitions(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQueryResponse.definitions)
  return _internal_definitions(index);
}
inline ::com::isima::bios::models::proto::ColumnDefinition* SelectQueryResponse::_internal_add_definitions() {
  return _impl_.definitions_.Add();
}
inline ::com::isima::bios::models::proto::ColumnDefinition* SelectQueryResponse::add_definitions() {
  ::com::isima::bios::models::proto::ColumnDefinition* _add = _internal_add_definitions();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.SelectQueryResponse.definitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::ColumnDefinition >&
SelectQueryResponse::definitions() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.SelectQueryResponse.definitions)
  return _impl_.definitions_;
}

// bool is_windowed_response = 3;
inline void SelectQueryResponse::clear_is_windowed_response() {
  _impl_.is_windowed_response_ = false;
}
inline bool SelectQueryResponse::_internal_is_windowed_response() const {
  return _impl_.is_windowed_response_;
}
inline bool SelectQueryResponse::is_windowed_response() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQueryResponse.is_windowed_response)
  return _internal_is_windowed_response();
}
inline void SelectQueryResponse::_internal_set_is_windowed_response(bool value) {
  
  _impl_.is_windowed_response_ = value;
}
inline void SelectQueryResponse::set_is_windowed_response(bool value) {
  _internal_set_is_windowed_response(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQueryResponse.is_windowed_response)
}

// int32 request_query_num = 4;
inline void SelectQueryResponse::clear_request_query_num() {
  _impl_.request_query_num_ = 0;
}
inline int32_t SelectQueryResponse::_internal_request_query_num() const {
  return _impl_.request_query_num_;
}
inline int32_t SelectQueryResponse::request_query_num() const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectQueryResponse.request_query_num)
  return _internal_request_query_num();
}
inline void SelectQueryResponse::_internal_set_request_query_num(int32_t value) {
  
  _impl_.request_query_num_ = value;
}
inline void SelectQueryResponse::set_request_query_num(int32_t value) {
  _internal_set_request_query_num(value);
  // @@protoc_insertion_point(field_set:com.isima.bios.models.proto.SelectQueryResponse.request_query_num)
}

// -------------------------------------------------------------------

// SelectResponse

// repeated .com.isima.bios.models.proto.SelectQueryResponse responses = 1;
inline int SelectResponse::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int SelectResponse::responses_size() const {
  return _internal_responses_size();
}
inline void SelectResponse::clear_responses() {
  _impl_.responses_.Clear();
}
inline ::com::isima::bios::models::proto::SelectQueryResponse* SelectResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:com.isima.bios.models.proto.SelectResponse.responses)
  return _impl_.responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQueryResponse >*
SelectResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:com.isima.bios.models.proto.SelectResponse.responses)
  return &_impl_.responses_;
}
inline const ::com::isima::bios::models::proto::SelectQueryResponse& SelectResponse::_internal_responses(int index) const {
  return _impl_.responses_.Get(index);
}
inline const ::com::isima::bios::models::proto::SelectQueryResponse& SelectResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:com.isima.bios.models.proto.SelectResponse.responses)
  return _internal_responses(index);
}
inline ::com::isima::bios::models::proto::SelectQueryResponse* SelectResponse::_internal_add_responses() {
  return _impl_.responses_.Add();
}
inline ::com::isima::bios::models::proto::SelectQueryResponse* SelectResponse::add_responses() {
  ::com::isima::bios::models::proto::SelectQueryResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:com.isima.bios.models.proto.SelectResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::isima::bios::models::proto::SelectQueryResponse >&
SelectResponse::responses() const {
  // @@protoc_insertion_point(field_list:com.isima.bios.models.proto.SelectResponse.responses)
  return _impl_.responses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace models
}  // namespace bios
}  // namespace isima
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::isima::bios::models::proto::MetricFunction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::isima::bios::models::proto::MetricFunction>() {
  return ::com::isima::bios::models::proto::MetricFunction_descriptor();
}
template <> struct is_proto_enum< ::com::isima::bios::models::proto::ContentRepresentation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::isima::bios::models::proto::ContentRepresentation>() {
  return ::com::isima::bios::models::proto::ContentRepresentation_descriptor();
}
template <> struct is_proto_enum< ::com::isima::bios::models::proto::AttributeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::isima::bios::models::proto::AttributeType>() {
  return ::com::isima::bios::models::proto::AttributeType_descriptor();
}
template <> struct is_proto_enum< ::com::isima::bios::models::proto::WindowType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::isima::bios::models::proto::WindowType>() {
  return ::com::isima::bios::models::proto::WindowType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED__5fbios_2fdata_2eproto
