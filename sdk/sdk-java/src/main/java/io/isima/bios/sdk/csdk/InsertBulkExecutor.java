/*
 * Copyright (C) 2025 Isima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.isima.bios.sdk.csdk;

import com.fasterxml.uuid.Generators;
import com.fasterxml.uuid.impl.TimeBasedGenerator;
import io.isima.bios.dto.IngestResponse;
import io.isima.bios.dto.IngestResultOrError;
import io.isima.bios.dto.bulk.InsertBulkSuccessResponse;
import io.isima.bios.models.AtomicOperationSpec;
import io.isima.bios.models.Record;
import io.isima.bios.sdk.errors.BiosClientError;
import io.isima.bios.sdk.errors.BiosClientErrorHandler;
import io.isima.bios.sdk.exceptions.BiosClientException;
import io.isima.bios.sdk.exceptions.IngestBulkBatchFailedException;
import io.isima.bios.sdk.impl.BiosClientUtils;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.atomic.AtomicInteger;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to track an InsertBulk operation.
 *
 * <p>An instance is created per InsertBulk request. One InsertBulk execution may consists of
 * multiple InsertBulk operations in C-SDK. This class manages such multiple operations.
 */
public final class InsertBulkExecutor<T extends InsertBulkSuccessResponse> {
  private static final Logger logger = LoggerFactory.getLogger(InsertBulkExecutor.class);

  private final BiosClient biosClient;

  private final CompletableFuture<List<Record>> future;
  private final AtomicOperationSpec atomicOperationSpec;
  private final List<String> sourceTexts;
  private final List<UUID> eventIds;
  private final Record[] results;
  private final AtomicInteger remaining;
  private final Map<Integer, BiosClientException> errors;
  private final int sessionId;
  private final String signalName;
  private final Long version;

  // An integer number issued by C-SDK that is used to stitch multiple (paging) insert bulk requests
  private long operationContext;

  /**
   * Constructor of the class.
   *
   * @param texts Input event texts.
   * @param sessionId Session ID
   * @param signalName SignalName
   * @param version Stream version of the session.
   * @param biosClient bios client
   */
  public InsertBulkExecutor(
      List<String> texts,
      AtomicOperationSpec atomicOperationSpec,
      int sessionId,
      String signalName,
      Long version,
      BiosClient biosClient) {
    future = new CompletableFuture<>();
    this.sessionId = sessionId;
    this.signalName = signalName;
    this.version = version;
    sourceTexts = texts;
    this.atomicOperationSpec = atomicOperationSpec;
    eventIds = new ArrayList<>();
    final TimeBasedGenerator generator = Generators.timeBasedGenerator();
    for (int i = 0; i < sourceTexts.size(); ++i) {
      eventIds.add(generator.generate());
    }
    this.biosClient = biosClient;
    results = new Record[texts.size()];
    remaining = new AtomicInteger(texts.size());
    errors = new ConcurrentSkipListMap<>();
    operationContext = 0; // 0 means not set
  }

  /**
   * Method to start the IngestBulk operation.
   *
   * @return self
   */
  public CompletableFuture<List<Record>> invokeAsync() {
    if (sourceTexts.isEmpty()) {
      // We don't start the operation for an empty request. The method more() won't be called.
      future.complete(Collections.emptyList());
    } else {
      // This would start callbacks from the C-SDK to the method more().
      operationContext = biosClient.insertBulkStart(sourceTexts.size(), this);
    }
    return this.future;
  }

  /**
   * Callback function invoked by C-SDK when it's ready to send another batch of the requests.
   *
   * <p>The S-SDK specifies the range of the indexes of events for the batch. This method generates
   * a IngestBulk request based on it and push it to the C-SDK.
   *
   * @param insertBulkContextId The context ID for this batch iteration generated by C-SDK.
   * @param fromIndex The index where the request batch should start, inclusive.
   * @param toIndex The index where the request batch should end, exclusive.
   */
  public void more(long insertBulkContextId, int fromIndex, int toIndex) {
    logger.debug(
        String.format("more: operationContext=%x %d:%d", insertBulkContextId, fromIndex, toIndex));
    final var insertBulkApiCaller =
        biosClient.makeInsertBulkCaller(
            signalName,
            version,
            insertBulkContextId,
            eventIds,
            sourceTexts,
            fromIndex,
            toIndex,
            atomicOperationSpec);

    insertBulkApiCaller
        .invokeAsync()
        .thenAccept(
            (response) -> {
              int index = fromIndex;
              for (Record result : response.getResults()) {
                results[index++] = result;
              }
              checkTerminate(insertBulkContextId, fromIndex, toIndex);
            })
        .exceptionally(
            (t) -> {
              logger.debug(
                  "The execution did not complete; ctx={}, from={}, to={}",
                  insertBulkContextId,
                  fromIndex,
                  toIndex);
              final BiosClientException ex =
                  (t.getCause() instanceof BiosClientException)
                      ? (BiosClientException) t.getCause()
                      : new BiosClientException(
                          BiosClientError.GENERIC_CLIENT_ERROR, "generic client error");
              if (ex instanceof IngestBulkBatchFailedException) {
                processBatchPartialError((IngestBulkBatchFailedException) ex, fromIndex);
                checkTerminate(insertBulkContextId, fromIndex, toIndex);
              } else {
                // We don't mark failure to results[] for REQUEST_TOO_LARGE since the S-SDK will
                // resend the
                // operation requests with smaller sizes.
                if (ex.getCode() != BiosClientError.REQUEST_TOO_LARGE) {
                  for (int i = fromIndex; i < toIndex; ++i) {
                    results[i] = null;
                    errors.put(i, ex);
                  }
                  checkTerminate(insertBulkContextId, fromIndex, toIndex);
                }
              }
              return null;
            });
  }

  private void processBatchPartialError(IngestBulkBatchFailedException iex, int fromIndex) {
    int index = fromIndex;
    for (IngestResultOrError result : iex.getBatchResponses()) {
      BiosClientError status;
      try {
        // Assumption: CSDK would have already converted status code correctly to a client error
        status = BiosClientUtils.statusToError(result.getStatusCode());
      } catch (BiosClientException ex) {
        status = BiosClientError.GENERIC_CLIENT_ERROR;
      }
      if (status == BiosClientError.OK) {
        results[index++] = new IngestResponse(result.getEventId(), result.getTimestamp());
      } else {
        results[index] = null;
        errors.put(index, new BiosClientException(status, result.getErrorMessage()));
        index++;
      }
    }
  }

  private void checkTerminate(long insertBulkContextId, int fromIndex, int toIndex) {
    int current = remaining.get();
    final int length = toIndex - fromIndex;
    while (!remaining.compareAndSet(current, current - length)) {
      current = remaining.get();
    }
    if (current == length) { // the last one
      if (errors.isEmpty()) {
        future.complete(Arrays.asList(results));
      } else {
        doBiosErrorHandling();
      }
      // There is a very slight chance of this method called before invoke() is done.
      // Back off if the operationContext is not set yet.
      int trials = 3;
      long sleepMillis = 10;
      while (operationContext == 0 && trials-- > 0) {
        try {
          Thread.sleep(sleepMillis);
        } catch (InterruptedException e) {
          logger.warn("Operation interrupted");
          Thread.currentThread().interrupt();
        }
        sleepMillis *= 2;
      }
      biosClient.insertBulkEnd(operationContext, sessionId, insertBulkContextId);
    }
  }

  /**
   * The getter to the new internal future.
   *
   * @return Bios Future
   */
  public CompletableFuture<List<Record>> getFuture() {
    return future;
  }

  private void doBiosErrorHandling() {
    final Map<Integer, Record> successfulResponses = new TreeMap<>();
    for (int i = 0; i < results.length; ++i) {
      if (results[i] != null) {
        successfulResponses.put(i, results[i]);
      }
    }
    // determine error code
    BiosClientError error = null;
    String reason = null;
    for (BiosClientException entry : errors.values()) {
      if (error == null || error == entry.getCode()) {
        error = entry.getCode();
      } else {
        error = BiosClientError.BULK_INGEST_FAILED;
      }
      if (reason == null) {
        reason = entry.getMessage();
      }
    }
    future.completeExceptionally(
        BiosClientErrorHandler.generateInsertBulkFailedException(
            error, reason, successfulResponses, errors));
  }
}
